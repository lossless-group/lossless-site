---
/**
 * /client/[client]/projects/[...slug].astro — Dynamic Route for Client Projects
 *
 * Modeled after /client/[client]/recommendations/[...slug].astro
 *
 * - Fetches content from 'client-projects' collection
 * - Filters by client name based on URL parameter
 * - Generates static paths for all client project entries
 * - Renders content using Layout, OneArticle, and OneArticleOnPage components
 */
import { getCollection } from 'astro:content';
import Layout from '@layouts/Layout.astro';
import OneArticle from '@layouts/OneArticle.astro';
import OneArticleOnPage from '@components/articles/OneArticleOnPage.astro';
import { processEntries, getReferenceSlug } from '@utils/slugify';

// Ensure page is prerendered as static HTML
export const prerender = true;

/**
 * getStaticPaths — Generates all static paths for the /client/[client]/projects/[slug] dynamic route.
 *
 * - Fetches all entries from the 'client-projects' collection
 * - Filters entries by client name (Laerdal, Param, etc.)
 * - For each entry, generates a path with client and slug params
 * - Ensures each entry has a slug and title (generates if missing)
 * - Returns array of { params, props } objects for Astro static generation
 */
export async function getStaticPaths() {
  // Get all projects from the general projects collection
  const allProjects = await getCollection('projects');
  
  // Get all MoC files to determine client-project mappings
  const allMoC = await getCollection('moc');
  
  const allPaths = [];

  // Process each MoC file to find client project assignments
  for (const mocEntry of allMoC) {
    const clientName = mocEntry.id.replace(/\.md$/, '').toLowerCase();
    
    // Parse the MoC content to find :::projects directive
    const mocContent = mocEntry.body;
    const projectsMatch = mocContent.match(/:::projects\s*\n(.*?)\n:::/s);
    
    if (projectsMatch) {
      // Extract project names from the directive
      const projectsList = projectsMatch[1];
      const projectNames = projectsList
        .split('\n')
        .map(line => line.trim())
        .filter(line => line.startsWith('- [[') && line.endsWith(']]'))
        .map(line => line.replace(/^- \[\[/, '').replace(/\]\]$/, ''));
      
      // Find matching projects in the general projects collection
      for (const projectName of projectNames) {
        const matchingProjects = allProjects.filter(project => {
          const projectPath = String(project.id);
          // Check if project path contains the project name
          return projectPath.toLowerCase().includes(projectName.toLowerCase());
        });
        
        // Generate paths for matching projects
        for (const project of matchingProjects) {
          const entryPath = String(project.id);
          const pathParts = entryPath.split('/');
          
          // Use frontmatter slug if available, otherwise generate from path
          const finalSlug = project.data.slug || pathParts[pathParts.length - 1].replace(/\.md$/, '').toLowerCase();
          
          // Convert directory parts to lowercase with dashes
          const slugifiedDirectories = pathParts.slice(0, -1).map(part => 
            part.toLowerCase().replace(/[^a-z0-9]/g, '-').replace(/-+/g, '-').replace(/^-+|-+$/g, '')
          );
          
          // Combine directory structure with final slug
          const projectSlug = [...slugifiedDirectories, finalSlug].join('/');
          
          allPaths.push({
            params: { client: clientName, slug: projectSlug },
            props: {
              entry: project,
              client: clientName
            }
          });
        }
      }
    }
  }

  return allPaths;
}

/**
 * Props interface for page rendering.
 * Supports client projects with client name and entry data.
 */
interface Props {
  entry: any;
  client: string;
}

const { entry, client } = Astro.props;

// Add content type to the data object for potential use in components
const contentData = {
  path: Astro.url.pathname,
  id: entry.id,
  title: entry.data.title?.replace(/\.(md|mdx)$/, '') || entry.data.title,
  client: client
};

---

<Layout 
  title={entry.data.title?.replace(/\.(md|mdx)$/, '') || entry.data.title}
  frontmatter={entry.data}
>
  <OneArticle
    Component={OneArticleOnPage}
    content={entry.body}
    markdownFile={entry.id}
    data={contentData}
  />
</Layout> 