---
/**
 * /client/[client]/projects/index.astro — Dynamic Client Projects Index
 * 
 * Uses the Map of Contents (MOC) system to dynamically list projects for each client
 * based on the :::projects directive in their MOC file (content/moc/<Client>.md).
 * 
 * Example MOC structure:
 * :::projects
 * - [[Augment-It]]
 * - [[Another Project]]
 * :::
 */

import fs from 'node:fs/promises';
import path from 'node:path';
import { getCollection } from 'astro:content';
import { toProperCase } from '@utils/slugify';
import { contentBasePath } from '@utils/envUtils';

// Layout and component imports
import Layout from '@layouts/Layout.astro';
import Hero from '@components/basics/Hero.astro';
import AnimationWrapper from '@components/basics/AnimationWrapper.astro';
import ProjectGallery from '@components/projects/ProjectGallery.svelte';
import ContentSection_SidebarTreeVariantB from '@layouts/content-sections/ContentSection_SidebarTreeVariantB.astro';
import OneArticleOnPage from '@components/articles/OneArticleOnPage.astro';

// Markdown processing imports
import { unified } from 'unified';
import remarkParse from 'remark-parse';
import remarkGfm from 'remark-gfm';
import remarkDirective from 'remark-directive';
import remarkImages from '@utils/markdown/remark-images'; 
import remarkBacklinks from '@utils/markdown/remark-backlinks';
import remarkCitations from '@utils/markdown/remark-citations';
import remarkTableOfContents from '@utils/markdown/remark-toc';
import { remarkDirectiveToComponent } from '@utils/markdown/remark-directives';
import type { Root } from 'mdast';

// Import markdown content for different projects
import mdWorkflow from '@generated/projects/Augment-It/Specs/Data Augmentation Workflow with Microfrontends.md?raw';
import mdOurApproach from '@generated/projects/ACE-It/Philosophy/Our-Approach.md?raw';

export const prerender = true;

// Remove YAML frontmatter when using ?raw imports so it doesn't render in the page
function stripFrontmatter(input: string): string {
  if (!input) return input;
  return input.replace(/^\uFEFF?\s*---[\s\S]*?\n---\s*/u, '');
}

// Process markdown content with unified processor
async function processMarkdown(mdContent: string, id: string, title: string) {
  if (!mdContent) return { mdastNode: null, contentData: null };
  
  const cleanedContent = stripFrontmatter(mdContent);
  
  const processor = unified()
    .use(remarkParse)
    .use(remarkGfm)
    .use(remarkDirective)
    .use(remarkDirectiveToComponent)
    .use(remarkImages) 
    .use(remarkBacklinks)
    .use(remarkCitations)
    .use(remarkTableOfContents);

  const mdast = processor.parse(cleanedContent);
  const mdastNode = await processor.run(mdast);

  const contentData = {
    path: Astro.url.pathname,
    id: id,
    title: title
  };

  return { mdastNode, contentData };
}

// Demo steps for Augment-It project
const augmentItDemoSteps = [
  { 
    title: 'Data Augmentation Workflow with Microfrontends', 
    href: '/projects/augment-it',
    type: 'orientation',
    description: 'Overview and introduction to the complete workflow'
  },
  { 
    title: 'Load Data', 
    href: '/projects/augment-it/record-collector',
    type: 'sequential',
    step: 1
  },
  { 
    title: 'Review & Enrich Records', 
    href: '/projects/augment-it/review-enrich-records',
    type: 'sequential',
    step: 2
  },
  { 
    title: 'Author Prompt Templates', 
    href: '/projects/augment-it/prompt-template-manager',
    type: 'sequential',
    step: 3
  },
  { 
    title: 'Choose AI Augmentation Option', 
    href: '/projects/augment-it/api-connector-service',
    type: 'sequential',
    step: 4
  },
  { 
    title: 'Review Request & Response', 
    href: '/projects/augment-it/request-reviewer',
    type: 'sequential',
    step: 5
  },
  { 
    title: 'Generate Insights', 
    href: '/projects/augment-it/highlight-collector',
    type: 'sequential',
    step: 6
  },
  { 
    title: 'Sync Back to Source', 
    href: '/projects/augment-it/sync',
    type: 'sequential',
    step: 7
  },
];

// Process content for each project
const augmentItContent = await processMarkdown(
  mdWorkflow, 
  'Augment-It/Specs/Data Augmentation Workflow with Microfrontends.md',
  'Data Augmentation Workflow with Microfrontends'
);

const aceItContent = await processMarkdown(
  mdOurApproach,
  'ACE-It/Philosophy/Our-Approach.md',
  'Our Approach: AI-Human Collaboration Principles'
);

// Function to dynamically load markdown content based on path
async function loadMarkdownContent(path: string): Promise<string | null> {
  try {
    // Convert path to import path format
    const importPath = path.replace(/^projects\//, '').replace(/\.md$/, '');
    const fullImportPath = `@generated/projects/${importPath}.md?raw`;
    
    // Dynamic import based on path
    const module = await import(fullImportPath);
    return module.default;
  } catch (error) {
    console.warn(`[CLIENT PROJECTS INDEX] Could not load markdown for path: ${path}`, error);
    return null;
  }
}

export async function getStaticPaths() {
  // Get all available clients from the moc directory
  const mocDir = path.resolve(contentBasePath, 'moc');
  
  try {
    const mocFiles = await fs.readdir(mocDir);
    const clientFiles = mocFiles.filter(file => file.endsWith('.md'));
    
    const paths = clientFiles.map(file => {
      const client = file.replace('.md', '').toLowerCase();
      return {
        params: { client },
        props: { client }
      };
    });
    
    console.log(`[CLIENT PROJECTS INDEX] Generated paths for clients:`, paths.map(p => p.params.client));
    return paths;
  } catch (error) {
    console.error('[CLIENT PROJECTS INDEX] Error reading MOC directory:', error);
    return [];
  }
}

const { client } = Astro.props;
const properClient = toProperCase(client);

// Load projects from the client's MOC file and transform to gallery format
let projectCovers: any[] = [];
let debugInfo = {
  mocPath: '',
  mocExists: false,
  mocContent: '',
  projectsBlockFound: false,
  projectsBlock: '',
  parsedProjects: [],
  allProjects: [],
  matchingProjects: [],
  matchingAttempts: [],
  error: null
};

try {
  const clientMocPath = path.resolve(contentBasePath, 'moc', `${properClient}.md`);
  debugInfo.mocPath = clientMocPath;
  console.log(`[CLIENT PROJECTS INDEX] Loading MOC file from: ${clientMocPath}`);
  
  const rawClientMoc = await fs.readFile(clientMocPath, 'utf-8');
  debugInfo.mocExists = true;
  debugInfo.mocContent = rawClientMoc;
  
  // Extract the :::projects ... ::: block
  const projectsBlockMatch = rawClientMoc.match(/:::projects([\s\S]*?):::/i);
  debugInfo.projectsBlockFound = !!projectsBlockMatch;
  
  if (projectsBlockMatch) {
    const block = projectsBlockMatch[1] || '';
    debugInfo.projectsBlock = block;
    const projectLines = block
      .split('\n')
      .map(line => line.trim())
      .filter(line => line.startsWith('-') || line.startsWith('*'));
    
    const mocProjectEntries = projectLines
      .map(line => {
        // Handle new directive format: { path: [[path]], title: "Title" }
        const directiveMatch = line.match(/^[-*]\s*\{\s*path:\s*\[\[([^\]]+)\]\]\s*,\s*title:\s*"([^"]+)"\s*\}/);
        if (directiveMatch) {
          return {
            name: directiveMatch[2].trim(),
            path: directiveMatch[1].trim(),
            canvasPath: null
          };
        }
        
        // Handle legacy [[canvas/path.canvas|Project Name]] syntax
        const linkMatch = line.match(/^[-*]\s*\[\[([^|\]]+)(?:\|([^\]]+))?\]\]/);
        if (linkMatch) {
          return {
            name: linkMatch[2] ? linkMatch[2].trim() : linkMatch[1].trim(),
            path: linkMatch[1].trim(),
            canvasPath: linkMatch[2] ? linkMatch[1].trim() : null
          };
        }
        
        // Handle plain list items
        const plainText = line.replace(/^[-*]\s*/, '').trim();
        return plainText ? { name: plainText, path: null, canvasPath: null } : null;
      })
      .filter(Boolean);
    
    debugInfo.parsedProjects = mocProjectEntries;
    console.log(`[CLIENT PROJECTS INDEX] Found ${mocProjectEntries.length} project entries in MOC for ${properClient}:`, mocProjectEntries);
    
    if (mocProjectEntries.length > 0) {
      // Get all projects from the collection
      const allProjects = await getCollection('projects');
      debugInfo.allProjects = allProjects.map(p => ({
        id: p.id,
        title: p.data?.title || 'No title',
        dataSlug: p.data?.slug || 'No data slug'
      }));
      
      console.log(`[CLIENT PROJECTS INDEX] Found ${allProjects.length} projects in collection:`, debugInfo.allProjects);
      
      // Match MOC project names to actual project entries and transform to gallery format
      for (const entry of mocProjectEntries) {
        // Try to find a matching project by title or slug with exact matching
        const matchingAttempt = {
          entryName: entry.name,
          normalizedEntryName: entry.name.toLowerCase().replace(/[-\s]/g, '-'),
          attempts: []
        };
        
        const matchingProject = allProjects.find(project => {
          const title = project.data.title || '';
          const slug = project.id || '';
          
          // First try exact matches
          const exactTitleMatch = title.toLowerCase() === entry.name.toLowerCase();
          const exactSlugMatch = slug.toLowerCase() === entry.name.toLowerCase();
          
          matchingAttempt.attempts.push({
            method: 'exact_title',
            projectTitle: title,
            projectSlug: slug,
            match: exactTitleMatch
          });
          
          matchingAttempt.attempts.push({
            method: 'exact_slug',
            projectTitle: title,
            projectSlug: slug,
            match: exactSlugMatch
          });
          
          if (exactTitleMatch || exactSlugMatch) {
            return true;
          }
          
          // Try matching by path from directive if available
          if (entry.path) {
            const pathMatch = slug.toLowerCase().includes(entry.path.toLowerCase()) || 
                             entry.path.toLowerCase().includes(slug.toLowerCase());
            
            matchingAttempt.attempts.push({
              method: 'path_match',
              projectTitle: title,
              projectSlug: slug,
              entryPath: entry.path,
              match: pathMatch
            });
            
            if (pathMatch) {
              return true;
            }
          }
          
          // Then try if the slug starts with the project name (for nested projects)
          const normalizedEntryName = entry.name.toLowerCase().replace(/[-\s]/g, '-');
          const slugParts = slug.toLowerCase().split('/');
          const slugStartMatch = slugParts[0] === normalizedEntryName;
          
          matchingAttempt.attempts.push({
            method: 'slug_start',
            projectTitle: title,
            projectSlug: slug,
            normalizedEntryName,
            slugParts,
            match: slugStartMatch
          });
          
          return slugStartMatch;
        });
        
        debugInfo.matchingAttempts.push(matchingAttempt);
        
        if (matchingProject) {
          // Check if this is Augment-It or ACE-It to add special content
          const projectId = matchingProject.id.toLowerCase();
          let projectContent = null;
          let projectDemoSteps = null;
          let projectHasSidebar = false;
          
          // Try to load content based on path from directive first
          if (entry.path) {
            const markdownContent = await loadMarkdownContent(entry.path);
            if (markdownContent) {
              projectContent = await processMarkdown(
                markdownContent,
                entry.path,
                entry.name
              );
            }
          }
          
          // Fallback to hardcoded content for known projects
          if (!projectContent) {
            if (projectId.includes('augment-it')) {
              projectContent = augmentItContent;
              projectDemoSteps = augmentItDemoSteps;
              projectHasSidebar = true;
            } else if (projectId.includes('ace-it')) {
              projectContent = aceItContent;
              projectDemoSteps = null;
              projectHasSidebar = false;
            }
          }
          
          // Transform to gallery format
          const projectCover = {
            id: matchingProject.id.toLowerCase().replace(/[-\s]/g, '-'),
            title: entry.name, // Use the title from the directive
            subtitle: matchingProject.data.description || `Project for ${properClient}`,
            href: `/projects/${matchingProject.id}`,
            hasSidebar: projectHasSidebar,
            demoSteps: projectDemoSteps,
            content: projectContent,
            useCases: [
              {
                title: 'Client Project',
                description: `Custom project for ${properClient}`
              }
            ],
            canvasPath: entry.canvasPath || `content/projects/${matchingProject.id}.canvas`
          };
          
          projectCovers.push(projectCover);
          debugInfo.matchingProjects.push({
            entryName: entry.name,
            projectId: matchingProject.id,
            path: entry.path,
            canvasPath: entry.canvasPath
          });
          console.log(`[CLIENT PROJECTS INDEX] Matched "${entry.name}" to project: ${matchingProject.id}${entry.canvasPath ? ` with canvas: ${entry.canvasPath}` : ''}`);
        } else {
          console.warn(`[CLIENT PROJECTS INDEX] Could not find project matching "${entry.name}" for ${properClient}`);
        }
      }
    }
  } else {
    console.warn(`[CLIENT PROJECTS INDEX] No :::projects directive found in moc/${properClient}.md`);
  }
} catch (error) {
  console.error(`[CLIENT PROJECTS INDEX] Error loading MOC file for ${properClient}:`, error);
  debugInfo.error = error.message;
}

// Fallback: if no projects found via MOC, show message
const hasProjects = projectCovers.length > 0;

const pageTitle = `${properClient} Projects`;
const pageDescription = hasProjects 
  ? `Explore ${projectCovers.length} project${projectCovers.length === 1 ? '' : 's'} for ${properClient}.`
  : `No projects currently configured for ${properClient}.`;
---

<Layout 
  title={pageTitle}
  description={pageDescription}
>
  <main>
    <Hero 
      title={pageTitle}
      description={pageDescription}
    />
    
    <AnimationWrapper>
      {hasProjects ? (
        <div class="projects-page-container">
          <!-- Project Gallery with Svelte -->
          <ProjectGallery projects={projectCovers} client:load />
          
          <!-- Hidden Project Content for Injection -->
          {projectCovers.filter(p => p.content).map(project => (
            <div id={`${project.id}-full-content`} class="collection-reader-pane" style="display: none;">
              {project.hasSidebar && project.demoSteps ? (
                <ContentSection_SidebarTreeVariantB 
                  steps={project.demoSteps} 
                  currentHref={`/client/${client}/projects`} 
                  seriesTitle={project.title}
                >
                  {project.content?.mdastNode && project.content?.contentData ? (
                    <OneArticleOnPage 
                      content={project.content.mdastNode} 
                      data={project.content.contentData} 
                    />
                  ) : (
                    <p>Content not available</p>
                  )}
                </ContentSection_SidebarTreeVariantB>
              ) : (
                <div class="project-content-simple">
                  {project.content?.mdastNode && project.content?.contentData ? (
                    <OneArticleOnPage 
                      content={project.content.mdastNode} 
                      data={project.content.contentData} 
                    />
                  ) : (
                    <p>Content not available</p>
                  )}
                </div>
              )}
            </div>
          ))}
        </div>
      ) : (
        <section class="projects-section">
          <div class="no-projects-message">
            <h2>No Projects Available</h2>
            <p>
              Projects for {properClient} are configured via the MOC (Map of Contents) system.
              To add projects, update the <code>:::projects</code> section in 
              <code>content/moc/{properClient}.md</code>.
            </p>
            
            <details class="debug-info">
              <summary>🔍 Debug Information (Click to expand)</summary>
              <div class="debug-content">
                <h4>MOC File Path:</h4>
                <code>{debugInfo.mocPath}</code>
                
                <h4>MOC File Exists:</h4>
                <code>{debugInfo.mocExists ? 'Yes' : 'No'}</code>
                
                {debugInfo.error && (
                  <div>
                    <h4>Error:</h4>
                    <code class="error">{debugInfo.error}</code>
                  </div>
                )}
                
                <h4>Projects Block Found:</h4>
                <code>{debugInfo.projectsBlockFound ? 'Yes' : 'No'}</code>
                
                {debugInfo.projectsBlock && (
                  <div>
                    <h4>Projects Block Content:</h4>
                    <pre><code>{debugInfo.projectsBlock}</code></pre>
                  </div>
                )}
                
                <h4>Parsed Projects ({debugInfo.parsedProjects.length}):</h4>
                <pre><code>{JSON.stringify(debugInfo.parsedProjects, null, 2)}</code></pre>
                
                <h4>All Available Projects ({debugInfo.allProjects.length}):</h4>
                <pre><code>{JSON.stringify(debugInfo.allProjects, null, 2)}</code></pre>
                
                <h4>Matching Attempts:</h4>
                <pre><code>{JSON.stringify(debugInfo.matchingAttempts, null, 2)}</code></pre>
                
                <h4>Matching Projects ({debugInfo.matchingProjects.length}):</h4>
                <pre><code>{JSON.stringify(debugInfo.matchingProjects, null, 2)}</code></pre>
                
                <h4>Full MOC File Content:</h4>
                <pre><code>{debugInfo.mocContent}</code></pre>
              </div>
            </details>
            
            <details class="moc-help">
              <summary>How to configure projects</summary>
              <div class="moc-example">
                <h4>Add this to <code>{contentBasePath}/moc/{properClient}.md</code>:</h4>
                <pre><code>:::projects
- {'{'} path: [[projects/Augment-It/Specs/Data Augmentation Workflow with Microfrontends]], title: "Augment-It" {'}'}
- {'{'} path: [[projects/ACE-It/Philosophy/Our-Approach]], title: "ACE-It" {'}'}
:::</code></pre>
                <p>
                  The <code>path</code> should match the project path in the 
                  <code>content/projects/</code> directory, and <code>title</code> will be used as the display name.
                </p>
                <p>
                  Legacy format is also supported:
                </p>
                <pre><code>:::projects
- [[Project Name]]
- [[Another Project]]
:::</code></pre>
              </div>
            </details>
          </div>
        </section>
      )}
    </AnimationWrapper>
  </main>
</Layout>

<style>
.projects-page-container {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-6, 1.5rem);
  margin: 2rem auto;
  padding: 0 var(--spacing-4, 1rem);
  width: 100%;
}

.projects-section {
  max-width: 1200px;
  margin: 0 auto;
  padding: 2rem 1.5rem;
}

.projects-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
  gap: 2rem;
  margin-top: 2rem;
}

.no-projects-message {
  text-align: center;
  max-width: 600px;
  margin: 4rem auto;
  padding: 2rem;
  background: var(--clr-surface-secondary, #f8f9fa);
  border-radius: 1rem;
  border: 1px solid var(--clr-border-subtle, #e1e5e9);
}

.no-projects-message h2 {
  color: var(--clr-text-primary, #1a1a1a);
  margin-bottom: 1rem;
  font-size: var(--fs-600, 1.5rem);
}

.no-projects-message p {
  color: var(--clr-text-secondary, #666);
  line-height: 1.6;
  margin-bottom: 1.5rem;
}

.no-projects-message code {
  background: var(--clr-surface-tertiary, #e9ecef);
  padding: 0.2rem 0.4rem;
  border-radius: 0.25rem;
  font-family: var(--ff-mono, 'Fira Code', monospace);
  font-size: 0.9em;
}

.debug-info {
  text-align: left;
  margin-top: 2rem;
  border: 2px solid #ff6b6b;
  border-radius: 0.5rem;
  background: #fff5f5;
}

.debug-info summary {
  cursor: pointer;
  font-weight: 600;
  color: #d63031;
  padding: 1rem;
  border-radius: 0.5rem;
  transition: background-color 0.2s ease;
}

.debug-info summary:hover {
  background: #ffe0e0;
}

.debug-content {
  padding: 1rem;
  border-top: 1px solid #ff6b6b;
  background: white;
}

.debug-content h4 {
  margin: 1.5rem 0 0.5rem 0;
  color: #2d3436;
  font-size: 0.9rem;
  font-weight: 600;
}

.debug-content h4:first-child {
  margin-top: 0;
}

.debug-content code {
  display: block;
  background: #f8f9fa;
  padding: 0.5rem;
  border-radius: 0.25rem;
  font-family: var(--ff-mono, 'Fira Code', monospace);
  font-size: 0.8rem;
  word-break: break-all;
}

.debug-content code.error {
  background: #ffe0e0;
  color: #d63031;
}

.debug-content pre {
  background: #f8f9fa;
  padding: 1rem;
  border-radius: 0.5rem;
  overflow-x: auto;
  margin: 0.5rem 0;
  border: 1px solid #e1e5e9;
}

.debug-content pre code {
  display: block;
  background: none;
  padding: 0;
  word-break: normal;
  white-space: pre;
}

.moc-help {
  text-align: left;
  margin-top: 2rem;
}

.moc-help summary {
  cursor: pointer;
  font-weight: 600;
  color: var(--clr-lossless-primary, #333);
  padding: 0.5rem;
  border-radius: 0.5rem;
  transition: background-color 0.2s ease;
}

.moc-help summary:hover {
  background: var(--clr-surface-tertiary, #e9ecef);
}

.moc-example {
  margin-top: 1rem;
  padding: 1rem;
  background: var(--clr-surface-primary, #fff);
  border-radius: 0.5rem;
  border: 1px solid var(--clr-border-subtle, #e1e5e9);
}

.moc-example h4 {
  margin-bottom: 0.5rem;
  color: var(--clr-text-primary, #1a1a1a);
  font-size: var(--fs-400, 1rem);
}

.moc-example pre {
  background: var(--clr-surface-tertiary, #e9ecef);
  padding: 1rem;
  border-radius: 0.5rem;
  overflow-x: auto;
  margin: 1rem 0;
}

.moc-example code {
  font-family: var(--ff-mono, 'Fira Code', monospace);
  font-size: 0.9em;
}

/* Styles for project content containers to work with TableOfContents */
.collection-reader-pane {
  flex: 1 1 auto;
  display: block;
  padding: 3rem 2rem;
  min-width: 0;
  overflow-y: auto;
  overflow-x: hidden;
  max-width: 100%;
  height: 100%;
  scroll-behavior: smooth;
}

/* When the content is displayed (not hidden), ensure proper scrolling */
.collection-reader-pane:not([style*="display: none"]) {
  height: calc(100vh - 4rem);
  overflow-y: auto;
}

.project-content-simple {
  padding: 2rem;
  max-width: 800px;
  margin: 0 auto;
}

@media (max-width: 768px) {
  .projects-grid {
    grid-template-columns: 1fr;
    gap: 1.5rem;
  }
  
  .projects-section {
    padding: 1.5rem 1rem;
  }
  
  .no-projects-message {
    margin: 2rem auto;
    padding: 1.5rem;
  }
}
</style>

<script>
  // Initialize Mermaid library globally
  window.initializeMermaid = async function() {
    if (!window.__MERMAID_LOADED__) {
      try {
        const mermaid = await import('https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs');
        
        // Configure Mermaid
        const mermaidConfig = {
          startOnLoad: false,
          theme: 'base',
          themeVariables: {
            darkMode: true,
            background: 'transparent',
            primaryColor: '#181818',
            primaryBorderColor: '#6fffd6',
            primaryTextColor: '#e0e0e0',
            secondaryColor: '#BF23F7',
            secondaryTextColor: '#50a3b3',
            clusterBkg: '#283139',
            lineColor: '#69e2e3',
            fontFamily: 'Open Sans, sans-serif',
          }
        };
        
        mermaid.default.initialize(mermaidConfig);
        window.mermaid = mermaid.default;
        window.__MERMAID_LOADED__ = true;
        
        // Initialize renderMermaidCharts function
        window.renderMermaidCharts = function() {
          if (window.mermaid) {
            window.mermaid.run();
          }
        };
        
        // Render any existing mermaid charts
        setTimeout(() => {
          window.renderMermaidCharts();
        }, 100);
      } catch (error) {
        console.error('[Client Projects Index] Failed to load Mermaid library:', error);
      }
    }
  };

  // Initialize Mermaid after page load
  document.addEventListener('DOMContentLoaded', () => {
    window.initializeMermaid();
  });
</script>
