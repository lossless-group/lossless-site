---
import { getCollection, getEntryBySlug, type CollectionEntry } from 'astro:content';
import { unified } from 'unified';
import remarkParse from 'remark-parse';
import remarkRehype from 'remark-rehype';
import rehypeStringify from 'rehype-stringify';
import { Debug } from 'astro:components';
import Layout from '@layouts/Layout.astro';
import OneArticleOnPage from '@components/articles/OneArticleOnPage.astro';
import remarkAsf from '@utils/markdown/remark-asf';
import remarkBacklinks from '@utils/markdown/remark-backlinks';
import remarkImages from '@utils/markdown/remark-images';
import remarkCallouts from '@utils/markdown/remark-callout-handler';
import rehypeCallouts from '@utils/markdown/rehype-callout-handler';
import type { Root as MdastRoot } from 'mdast';
// @ts-expect-error - Using local type definition for HAST Root
import type { Root } from '@types/hast';
import fs from 'fs';
import path from 'path';
import { astDebugger } from '../../utils/debug/ast-debugger';

// Turn debug mode on/off here
const DEBUG_AST = process.env.DEBUG_AST === 'true';

// Debug directory and file writing setup
function createDebugDir() {
  const baseDebugDir = path.join(process.cwd(), 'debug');
  if (!fs.existsSync(baseDebugDir)) {
    fs.mkdirSync(baseDebugDir);
  }

  // Get current date in YYYY-MM-DD format
  const now = new Date();
  const dateStr = now.toISOString().split('T')[0];
  const debugDir = path.join(baseDebugDir, `${dateStr}_01`);
  
  if (!fs.existsSync(debugDir)) {
    fs.mkdirSync(debugDir);
  }
  return debugDir;
}

// Only create debug directory and write files if debugging is enabled
if (DEBUG_AST) {
  createDebugDir();
}

// Helper function for debug file writing
const writeDebugFile = (name: string, content: any) => {
  if (DEBUG_AST) {
    astDebugger.writeDebugFile(name, content);
  }
};

export async function getStaticPaths() {
  const vocabularyEntries = await getCollection('vocabulary');
  console.log('Found entries:', vocabularyEntries.map(e => ({ slug: e.data.slug, id: e.id })));
  return vocabularyEntries.map(entry => {
    // Generate slug and title from the entry ID if not present
    const filename = entry.id.replace(/\.md$/, '');
    const slug = entry.data.slug || filename.toLowerCase().replace(/\s+/g, '-');
    const title = entry.data.title || filename;
    return {
      params: { vocabulary: slug },
      props: { entry }
    };
  });
}

interface Props {
  entry: CollectionEntry<'vocabulary'>;
}

const { entry } = Astro.props;

// Process with our custom remark plugins in discrete steps
const parsedAst = await unified()
  .use(remarkParse)
  .process(entry.body);
writeDebugFile('1-parsed-ast', parsedAst.data);
console.log('1. Parsed AST:', parsedAst.data);

const calloutsAst = await unified()
  .use(remarkParse)
  .use(remarkCallouts)
  .process(entry.body);
writeDebugFile('2-callouts-ast', calloutsAst.data);
console.log('2. Callouts AST:', calloutsAst.data);

const asfAst = await unified()
  .use(remarkParse)
  .use(remarkAsf)
  .process(entry.body);
writeDebugFile('3-asf-ast', asfAst.data);
console.log('3. ASF AST:', asfAst.data);

const backlinksAst = await unified()
  .use(remarkParse)
  .use(remarkBacklinks)
  .process(entry.body);
writeDebugFile('4-backlinks-ast', backlinksAst.data);
console.log('4. Backlinks AST:', backlinksAst.data);

const imagesAst = await unified()
  .use(remarkParse)
  .use(remarkImages)
  .process(entry.body);
writeDebugFile('5-images-ast', imagesAst.data);
console.log('5. Images AST:', imagesAst.data);

const hastAst = await unified()
  .use(remarkParse)
  .use(remarkRehype)
  .process(entry.body);
writeDebugFile('6-hast-ast', hastAst.data);
console.log('6. HAST AST:', hastAst.data);

const calloutsHastAst = await unified()
  .use(remarkParse)
  .use(remarkCallouts)
  .use(remarkRehype)
  .process(entry.body);
writeDebugFile('7-callouts-hast-ast', calloutsHastAst.data);
console.log('7. Callouts HAST AST:', calloutsHastAst.data);

// Final processing with all plugins
const processedContent = await unified()
  .use(remarkParse)           // 1. Parse markdown to MDAST
  .use(remarkCallouts)        // 2. Transform blockquotes to callout nodes
  .use(remarkAsf)            // 3. Process ASF syntax
  .use(remarkBacklinks)      // 4. Process backlinks
  .use(remarkImages)         // 5. Process images
  .use(remarkRehype)         // 6. Convert MDAST to HAST
  .use(rehypeStringify)      // 7. Convert HAST to HTML
  .process(entry.body);

const htmlContent = processedContent.toString();
writeDebugFile('8-final-html', htmlContent);
console.log('8. Final HTML:', htmlContent);

console.log('Entry:', { id: entry.id, title: entry.data.title, slug: entry.data.slug });

---

<Layout title={entry.data.title || entry.data.slug}>
  {DEBUG_AST && (
    <>
      <h2>Debug Output:</h2>
      <h3>1. After Parse:</h3>
      <Debug {parsedAst} />
      <h3>2. After Callouts:</h3>
      <Debug {calloutsAst} />
      <h3>3. After ASF:</h3>
      <Debug {asfAst} />
      <h3>4. After Backlinks:</h3>
      <Debug {backlinksAst} />
      <h3>5. After Images:</h3>
      <Debug {imagesAst} />
      <h3>6. After HAST:</h3>
      <Debug {hastAst} />
      <h3>7. After Callouts HAST:</h3>
      <Debug {calloutsHastAst} />
      <hr />
    </>
  )}
  <OneArticleOnPage
    title={entry.data.title || entry.data.slug}
    content={htmlContent}
  />
</Layout>