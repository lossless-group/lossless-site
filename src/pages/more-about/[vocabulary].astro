---
import { getCollection, type CollectionEntry } from 'astro:content';
import { unified } from 'unified';
import remarkParse from 'remark-parse';
import remarkAsf from '@utils/markdown/remark-asf';
import remarkBacklinks from '@utils/markdown/remark-backlinks';
import remarkImages from '@utils/markdown/remark-images';
import remarkCallouts from '@utils/markdown/remark-callout-handler';
import Layout from '@layouts/Layout.astro';
import OneArticleOnPage from '@components/articles/OneArticleOnPage.astro';
import DebugMarkdown from '@components/markdown/DebugMarkdown.astro';

// Ensure page is prerendered as static HTML
export const prerender = true;

export async function getStaticPaths() {
  const vocabularyEntries = await getCollection('vocabulary');
  return vocabularyEntries.map(entry => {
    // Generate slug and title from the entry ID if not present
    const filename = entry.id.replace(/\.md$/, '');
    const slug = entry.data.slug || filename.toLowerCase().replace(/\s+/g, '-');
    const title = entry.data.title || filename;
    return {
      params: { vocabulary: slug },
      props: { entry }
    };
  });
}

interface Props {
  entry: CollectionEntry<'vocabulary'>;
}

const { entry } = Astro.props;

// Process with our custom remark plugins to get MDAST
const mdast = await unified()
  .use(remarkParse)           // 1. Parse markdown to MDAST
  .use(remarkCallouts)        // 2. Transform blockquotes to callout nodes
  .use(remarkAsf, { markdownFile: entry.id })            // 3. Process ASF syntax
  .use(remarkBacklinks)      // 4. Process backlinks
  .use(remarkImages)         // 5. Process images
  .parse(entry.body);        // Note: We stop at MDAST, no conversion to HAST/HTML
---

<Layout title={entry.data.title || entry.data.slug}>
  <DebugMarkdown 
    content={entry.body}
    markdownFile={entry.id}
  />
  <OneArticleOnPage
    title={entry.data.title || entry.data.slug}
    content={mdast}
  />
</Layout>