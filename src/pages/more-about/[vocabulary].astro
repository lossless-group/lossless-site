---
import { getCollection, type CollectionEntry } from 'astro:content';
import Layout from '@layouts/Layout.astro';
import OneArticle from '@layouts/OneArticle.astro';
import OneArticleOnPage from '@components/articles/OneArticleOnPage.astro';
import remarkAsf from '@utils/markdown/remark-asf';
import { unified } from 'unified';
import remarkParse from 'remark-parse';
import remarkRehype from 'remark-rehype';
import rehypeStringify from 'rehype-stringify';
import { Debug } from 'astro:components';

export async function getStaticPaths() {
  const vocabularyEntries = await getCollection('vocabulary');
  console.log('Found entries:', vocabularyEntries.map(e => ({ slug: e.data.slug, id: e.id })));
  return vocabularyEntries.map(entry => {
    // Use the entry ID (filename) as fallback if slug is not present
    const slug = entry.data.slug || entry.id.replace(/\.md$/, '').toLowerCase().replace(/\s+/g, '-');
    console.log('Processing entry:', { id: entry.id, slug });
    return {
      params: { vocabulary: slug },
      props: { entry }
    };
  });
}

export const prerender = true;

type Props = {
  entry: CollectionEntry<'vocabulary'>;
};

const { entry }: Props = Astro.props;
if (!entry) {
  throw new Error("Vocabulary entry not found");
}

// Process the content with our custom remark plugin
const processedContent = await unified()
  .use(remarkParse)        // Parse markdown to mdast
  .use(remarkAsf, { markdownFile: entry.id })         // Transform mdast with file path
  .use(remarkRehype)      // Convert mdast to hast
  .use(rehypeStringify)   // Stringify hast to HTML
  .process(entry.body);

console.log('Entry:', { id: entry.id, title: entry.data.title, slug: entry.data.slug });
console.log('Processed content:', String(processedContent).substring(0, 100) + '...');

---

<Layout title={entry.data.title || entry.data.slug}>
  <Debug {entry} />
  <Debug processedContent={String(processedContent)} />
  <OneArticle
    Component={OneArticleOnPage}
    data={{
      title: entry.data.title || entry.data.slug,
      content: String(processedContent)
    }}
  />
</Layout>