---
import { getCollection, type CollectionEntry } from 'astro:content';
import { unified } from 'unified';
import remarkParse from 'remark-parse';
import remarkRehype from 'remark-rehype';
import rehypeStringify from 'rehype-stringify';
import { Debug } from 'astro:components';
import Layout from '@layouts/Layout.astro';
import OneArticle from '@layouts/OneArticle.astro';
import OneArticleOnPage from '@components/articles/OneArticleOnPage.astro';
import remarkAsf from '@utils/markdown/remark-asf';
import remarkBacklinks from '@utils/markdown/remark-backlinks';
import remarkImages from '@utils/markdown/remark-images';

export async function getStaticPaths() {
  const vocabularyEntries = await getCollection('vocabulary');
  console.log('Found entries:', vocabularyEntries.map(e => ({ slug: e.data.slug, id: e.id })));
  return vocabularyEntries.map(entry => {
    // Generate slug and title from the entry ID if not present
    const filename = entry.id.replace(/\.md$/, '');
    const slug = entry.data.slug || filename.toLowerCase().replace(/\s+/g, '-');
    const title = entry.data.title || filename
      .split(/[\s-]+/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');

    // Create a new entry with updated data
    const updatedEntry = {
      ...entry,
      data: {
        ...entry.data,
        title,
        slug,
        aliases: entry.data.aliases || []
      }
    };

    console.log('Processing entry:', { id: entry.id, slug, title });
    return {
      params: { vocabulary: slug },
      props: { entry: updatedEntry }
    };
  });
}

export const prerender = true;

type Props = {
  entry: CollectionEntry<'vocabulary'>;
};

const { entry }: Props = Astro.props;
if (!entry) {
  throw new Error("Vocabulary entry not found");
}

// Process the content with our custom remark plugin
const processedContent = await unified()
  .use(remarkParse)        // Parse markdown to mdast
  .use(remarkAsf, { markdownFile: entry.id })         // Transform mdast with file path
  .use(remarkBacklinks)
  .use(remarkImages, {
    renderInFrontmatter: false,
    defaultAltText: 'Vocabulary Entry Image'
  })
  .use(remarkRehype)      // Convert mdast to hast
  .use(rehypeStringify)   // Stringify hast to HTML
  .process(entry.body);

console.log('Entry:', { id: entry.id, title: entry.data.title, slug: entry.data.slug });
console.log('Processed content:', String(processedContent).substring(0, 100) + '...');

---

<Layout title={entry.data.title || entry.data.slug}>
  <Debug {entry} />
  <Debug processedContent={String(processedContent)} />
  <OneArticle
    Component={OneArticleOnPage}
    data={{
      title: entry.data.title || entry.data.slug,
      content: String(processedContent)
    }}
  />
</Layout>