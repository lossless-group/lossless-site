---
import { DEBUG_TOC } from '@utils/envUtils';
import { extractAllText, slugify } from '@utils/slugify';

interface Props {
  node: {
    type?: string;
    children?: any[];
  } | undefined;
}

interface TocItem {
  text: string;
  slug: string;
  depth: number;
  children?: TocItem[];
}

const { node } = Astro.props;

const isValidToc = node?.type === 'list' && Array.isArray(node.children);

function getLinkText(linkNode): string {
  if (Array.isArray(linkNode?.children)) {
    return extractAllText(linkNode.children)
      .replace(/:\s*$/, '') // strip trailing colon
      .replace(/^â€¢\s*/, ''); // strip bullet prefix
  }
  return '';
}

function buildTocTree(listNode, depth = 1): TocItem[] {
  if (!listNode?.children || !Array.isArray(listNode.children)) {
    if (DEBUG_TOC) {
      console.log(`[TableOfContents] buildTocTree: Invalid listNode or children at depth ${depth}:`, listNode);
    }
    return [];
  }

  return listNode.children.map((item, index) => {
    if (!item) {
      if (DEBUG_TOC) {
        console.warn(`[TableOfContents] Skipping undefined item at index ${index}, depth ${depth}`);
      }
      return null;
    }

    const firstLink = item.children?.[0]?.children?.[0];
    const text = getLinkText(firstLink);
    const slug = slugify(text.trim());
    
    // Find nested lists
    const nestedList = item.children?.find(child => child.type === 'list');
    const children = nestedList ? buildTocTree(nestedList, depth + 1) : [];

    if (DEBUG_TOC) {
      console.log(`[TableOfContents] Building item:`, { text, slug, depth, hasChildren: children.length > 0 });
    }

    const tocItem = {
      text: text.trim(),
      slug,
      depth,
      children
    };

    return tocItem;
  }).filter(item => item && item.text); // Only include valid items with text
}

const rawTocItems = isValidToc ? buildTocTree(node) : [];
const tocItems = removeDuplicates(rawTocItems);

if (DEBUG_TOC) {
  console.log('[TableOfContents] isValidToc:', isValidToc);
  console.log('[TableOfContents] Raw tocItems length:', rawTocItems.length);
  console.log('[TableOfContents] Cleaned tocItems length:', tocItems.length);
  console.log('[TableOfContents] tocItems:', tocItems);
}

// Remove duplicate items where a parent has the same text as its first child
function removeDuplicates(items: TocItem[]): TocItem[] {
  return items.map(item => {
    if (item.children && item.children.length > 0) {
      // Check if the first child has the same text as the parent
      const firstChild = item.children[0];
      if (firstChild && firstChild.text === item.text) {
        // Remove the duplicate first child, keep the rest
        const remainingChildren = item.children.slice(1);
        return {
          ...item,
          children: removeDuplicates(remainingChildren)
        };
      } else {
        // Recursively clean children
        return {
          ...item,
          children: removeDuplicates(item.children)
        };
      }
    }
    return item;
  });
}

// Flatten the TOC tree into a simple array for easier rendering
function flattenTocItems(items: TocItem[]): (TocItem & { hasChildren: boolean })[] {
  const flattened: (TocItem & { hasChildren: boolean })[] = [];
  
  function flatten(itemList: TocItem[]) {
    itemList.forEach(item => {
      if (item && typeof item === 'object' && item.text) {
        // Add hasChildren property to the flattened item
        const flatItem = {
          ...item,
          hasChildren: item.children && item.children.length > 0
        };
        flattened.push(flatItem);
        if (item.children && item.children.length > 0) {
          flatten(item.children);
        }
      }
    });
  }
  
  flatten(items);
  return flattened;
}

const flatTocItems = flattenTocItems(tocItems);
---

<aside class="toc-sidebar" id="toc-sidebar">
  <div class="toc-header">
    <h2 class="toc-title">Table of Contents</h2>
    <button class="toc-collapse-btn" aria-label="Collapse Table of Contents">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="18,15 12,9 6,15"></polyline>
      </svg>
    </button>
  </div>
  
  <div class="toc-scroll-area" id="toc-scroll-area">
    {flatTocItems.length > 0 ? (
      <Fragment>
        <nav aria-label="Table of Contents">
          <ul class="toc-list">
            {flatTocItems.map((item, index) => {
              const depthClass = `toc-item toc-depth-${item.depth || 1}`;
              return (
                <li class={depthClass} data-depth={item.depth || 1} data-slug={item.slug}>
                  <a 
                    href={`#${item.slug}`} 
                    class="toc-link"
                    data-slug={item.slug}
                    title={item.text}
                  >
                    {item.hasChildren ? (
                      <button 
                        class="toc-toggle" 
                        data-parent-slug={item.slug}
                        data-expanded="true"
                        aria-label={`Toggle ${item.text} section`}
                      >
                        <svg class="toc-chevron expanded" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                          <polyline points="6,9 12,15 18,9"></polyline>
                        </svg>
                      </button>
                    ) : (
                      <span class="toc-bullet"></span>
                    )}
                    <span class="toc-text">{item.text}</span>
                  </a>
                </li>
              );
            })}
          </ul>
        </nav>
        
        <div class="toc-progress-bar">
          <div class="toc-progress-fill" id="toc-progress-fill"></div>
        </div>
      </Fragment>
    ) : (
      <div class="toc-empty-message">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
          <polyline points="14,2 14,8 20,8"></polyline>
          <line x1="16" y1="13" x2="8" y2="13"></line>
          <line x1="16" y1="17" x2="8" y2="17"></line>
          <polyline points="10,9 9,9 8,9"></polyline>
        </svg>
        <span>No table of contents available</span>
      </div>
    )}
  </div>
</aside>


<style>
/* ===== Modern Table of Contents Styles ===== */

.toc-sidebar {
  margin-left: 1rem;
  min-width: 280px;
  max-width: 320px;
  width: 320px;
  position: sticky;
  top: 2rem;
  align-self: flex-start;
  max-height: calc(100vh - 4rem);
  display: flex;
  flex-direction: column;
  background: rgba(0, 0, 0, 0.3);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
  transition: all 0.3s ease;
}

.toc-sidebar:hover {
  border-color: var(--clr-lossless-accent--brightest);
  box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
  width: 800px;
  max-width: 800px;
}

.toc-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  background: rgba(255, 255, 255, 0.05);
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.toc-title {
  font-size: 0.9rem;
  font-weight: 600;
  margin: 0;
  color: var(--clr-lossless-accent--brightest);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.toc-collapse-btn {
  background: none;
  border: none;
  color: var(--clr-lossless-primary-light);
  cursor: pointer;
  padding: 4px;
  border-radius: 6px;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.toc-collapse-btn:hover {
  background: rgba(255, 255, 255, 0.1);
  color: var(--clr-lossless-accent--brightest);
  transform: translateY(-1px);
}

.toc-scroll-area {
  overflow-y: auto;
  flex-grow: 1;
  padding: 0.75rem 0;
  scrollbar-width: thin;
  scrollbar-color: var(--clr-lossless-accent--brightest) transparent;
}

.toc-scroll-area::-webkit-scrollbar {
  width: 4px;
}

.toc-scroll-area::-webkit-scrollbar-track {
  background: transparent;
}

.toc-scroll-area::-webkit-scrollbar-thumb {
  background: var(--clr-lossless-accent--brightest);
  border-radius: 2px;
}

.toc-list,
.toc-sublist {
  list-style: none;
  margin: 0;
  padding: 0;
}

.toc-sublist {
  margin-top: 0.25rem;
}

.toc-item {
  margin: 0;
  position: relative;
  transition: opacity 0.2s ease, max-height 0.2s ease;
}

.toc-item.hidden {
  opacity: 0;
  max-height: 0;
  overflow: hidden;
  pointer-events: none;
}

.toc-link {
  display: flex;
  align-items: center;
  padding: 0.5rem 1rem;
  text-decoration: none;
  color: var(--clr-lossless-primary-light);
  transition: all 0.2s ease;
  border-left: 3px solid transparent;
  position: relative;
  overflow: hidden;
  flex-grow: 1;
}

.toc-link::before,
.toc-link::after {
  content: '';
  position: absolute;
  height: 1px;
  width: 0;
  background: linear-gradient(90deg, 
    var(--clr-lossless-accent--brightest), 
    rgba(255, 255, 255, 0.1)
  );
  transition: width 0.3s ease;
}

.toc-link::before {
  top: 0;
  left: 0;
}

.toc-link::after {
  bottom: 0;
  left: 0;
}

.toc-link:hover::before,
.toc-link:hover::after,
.toc-link.active::before,
.toc-link.active::after {
  width: 100%;
}

.toc-link:hover {
  color: white;
  border-left-color: var(--clr-lossless-accent--brightest);
}

.toc-link.active {
  color: white;
  border-left-color: var(--clr-lossless-accent--brightest);
  background: rgba(255, 255, 255, 0.03);
}

.toc-toggle {
  background: none;
  border: none;
  padding: 0;
  margin-right: 0.75rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  transition: all 0.2s ease;
}

.toc-chevron {
  width: 12px;
  height: 12px;
  color: var(--clr-lossless-primary-light);
  transition: all 0.2s ease;
}

.toc-chevron.expanded {
  transform: rotate(0deg);
}

.toc-chevron.collapsed {
  transform: rotate(-90deg);
}

.toc-link:hover .toc-toggle .toc-chevron,
.toc-toggle:hover .toc-chevron {
  color: var(--clr-lossless-accent--brightest);
}

.toc-bullet {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: currentColor;
  margin-right: 0.75rem;
  flex-shrink: 0;
  transition: all 0.2s ease;
  position: relative;
  z-index: 1;
}

.toc-link:hover .toc-bullet,
.toc-link.active .toc-bullet {
  background: white;
  transform: scale(1.2);
}

.toc-text {
  font-size: 0.875rem;
  line-height: 1.4;
  word-wrap: break-word;
  position: relative;
  z-index: 1;
}

/* Depth-based styling */
.toc-depth-1 .toc-link {
  font-weight: 500;
  padding-left: 1rem;
}

.toc-depth-2 .toc-link {
  font-size: 0.85rem;
  padding-left: 2rem;
}

.toc-depth-3 .toc-link {
  font-size: 0.8rem;
  opacity: 0.9;
  padding-left: 3rem;
}

.toc-depth-4 .toc-link,
.toc-depth-5 .toc-link,
.toc-depth-6 .toc-link {
  font-size: 0.75rem;
  opacity: 0.8;
  padding-left: 4rem;
}

.toc-progress-bar {
  height: 3px;
  background: rgba(255, 255, 255, 0.1);
  position: relative;
  margin: 0.5rem 1rem 1rem;
  border-radius: 2px;
  overflow: hidden;
}

.toc-progress-fill {
  height: 100%;
  background: linear-gradient(90deg, 
    var(--clr-lossless-accent--brightest), 
    #00ff88
  );
  width: 0%;
  transition: width 0.3s ease;
  border-radius: 2px;
}

.toc-empty-message {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.75rem;
  padding: 2rem 1.5rem;
  text-align: center;
  color: var(--clr-lossless-primary-light);
  opacity: 0.7;
}

.toc-empty-message svg {
  opacity: 0.5;
}

.toc-empty-message span {
  font-size: 0.875rem;
  font-style: italic;
}

/* Responsive design */
@media (max-width: 1200px) {
  .toc-sidebar {
    min-width: 260px;
    max-width: 280px;
  }
}

@media (max-width: 1024px) {
  .toc-sidebar {
    display: none;
  }
}

/* Mobile TOC (if needed in future) */
@media (max-width: 768px) {
  .toc-sidebar {
    position: fixed;
    top: 0;
    right: -100%;
    width: 280px;
    height: 100vh;
    z-index: 1000;
    transition: right 0.3s ease;
    border-radius: 0;
    border-right: none;
  }
  
  .toc-sidebar.mobile-open {
    right: 0;
  }
}

/* Animation for collapse/expand */
.toc-sidebar.collapsed .toc-scroll-area {
  max-height: 0;
  opacity: 0;
  transform: translateY(-10px);
}

.toc-sidebar.collapsed .toc-collapse-btn svg {
  transform: rotate(180deg);
}

/* Focus styles for accessibility */
.toc-link:focus {
  outline: 2px solid var(--clr-lossless-accent--brightest);
  outline-offset: 2px;
}

.toc-collapse-btn:focus {
  outline: 2px solid var(--clr-lossless-accent--brightest);
  outline-offset: 2px;
}
</style>

<script>
class TableOfContentsManager {
  constructor() {
    this.tocSidebar = document.getElementById('toc-sidebar');
    this.tocScrollArea = document.getElementById('toc-scroll-area');
    this.tocProgressFill = document.getElementById('toc-progress-fill');
    this.collapseBtn = this.tocSidebar?.querySelector('.toc-collapse-btn');
    this.tocLinks = this.tocSidebar?.querySelectorAll('.toc-link');
    this.headings = [];
    this.currentActiveLink = null;
    this.scrollTimeout = null;
    
    if (this.tocSidebar) {
      this.init();
    }
  }

  init() {
    console.log('[TOC] Initializing TableOfContentsManager');
    this.collectHeadings();
    this.setupEventListeners();
    this.updateActiveLink();
    this.updateScrollProgress();
    console.log('[TOC] Found', this.tocLinks?.length || 0, 'TOC links');
    console.log('[TOC] Found', this.headings.length, 'headings on page');
  }

  collectHeadings() {
    // Collect all headings that have IDs (generated by the markdown processor)
    this.headings = Array.from(document.querySelectorAll('h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]'))
      .map(heading => ({
        element: heading,
        id: heading.id,
        top: 0
      }));
    
    this.updateHeadingPositions();
  }

  updateHeadingPositions() {
    this.headings.forEach(heading => {
      heading.top = heading.element.getBoundingClientRect().top + window.scrollY;
    });
  }

  setupEventListeners() {
    // Collapse/expand functionality
    this.collapseBtn?.addEventListener('click', () => {
      this.toggleCollapse();
    });

    // Toggle functionality for nested items
    const toggleButtons = this.tocSidebar?.querySelectorAll('.toc-toggle');
    toggleButtons?.forEach(button => {
      button.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.toggleSection(button);
      });
    });

    // Smooth scrolling for TOC links
    this.tocLinks?.forEach(link => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        const href = link.getAttribute('href');
        console.log('[TOC] Click event fired for:', href);
        
        // Direct, simple approach
        if (href && href.startsWith('#')) {
          const id = href.substring(1);
          const element = document.getElementById(id);
          console.log('[TOC] Looking for element with id:', id, 'Found:', !!element);
          
          if (element) {
            // Just use the native behavior
            element.scrollIntoView({ behavior: 'smooth', block: 'start' });
            window.history.replaceState(null, null, href);
          }
        }
      });
    });

    // Scroll tracking with throttling
    let scrollTimeout;
    window.addEventListener('scroll', () => {
      if (scrollTimeout) {
        cancelAnimationFrame(scrollTimeout);
      }
      scrollTimeout = requestAnimationFrame(() => {
        this.updateActiveLink();
        this.updateScrollProgress();
      });
    }, { passive: true });

    // Update positions on resize
    window.addEventListener('resize', () => {
      clearTimeout(this.scrollTimeout);
      this.scrollTimeout = setTimeout(() => {
        this.updateHeadingPositions();
        this.updateActiveLink();
      }, 100);
    });
  }

  toggleCollapse() {
    this.tocSidebar?.classList.toggle('collapsed');
    
    // Update aria-label
    const isCollapsed = this.tocSidebar?.classList.contains('collapsed');
    if (this.collapseBtn) {
      this.collapseBtn.setAttribute('aria-label', 
        isCollapsed ? 'Expand Table of Contents' : 'Collapse Table of Contents'
      );
    }
  }

  toggleSection(button) {
    const isExpanded = button.getAttribute('data-expanded') === 'true';
    const parentSlug = button.getAttribute('data-parent-slug');
    const chevron = button.querySelector('.toc-chevron');
    
    console.log('[TOC] Toggling section:', parentSlug, 'Currently expanded:', isExpanded);
    
    // Find the parent item
    const parentItem = this.tocSidebar?.querySelector(`[data-slug="${parentSlug}"]`);
    if (!parentItem) return;
    
    const parentDepth = parseInt(parentItem.getAttribute('data-depth')) || 1;
    
    // Find all child items (items that come after this one with greater depth)
    const allItems = Array.from(this.tocSidebar?.querySelectorAll('.toc-item') || []);
    const parentIndex = allItems.indexOf(parentItem);
    
    let childItems = [];
    for (let i = parentIndex + 1; i < allItems.length; i++) {
      const itemDepth = parseInt(allItems[i].getAttribute('data-depth')) || 1;
      if (itemDepth <= parentDepth) {
        // Reached a sibling or parent level, stop
        break;
      }
      childItems.push(allItems[i]);
    }
    
    console.log('[TOC] Found', childItems.length, 'child items for', parentSlug);
    
    if (isExpanded) {
      // Collapse: hide children
      childItems.forEach(item => item.classList.add('hidden'));
      button.setAttribute('data-expanded', 'false');
      chevron?.classList.remove('expanded');
      chevron?.classList.add('collapsed');
    } else {
      // Expand: show children
      childItems.forEach(item => item.classList.remove('hidden'));
      button.setAttribute('data-expanded', 'true');
      chevron?.classList.remove('collapsed');
      chevron?.classList.add('expanded');
    }
  }

  scrollToHeading(href) {
    const targetId = href?.replace('#', '');
    const targetElement = targetId ? document.getElementById(targetId) : null;
    
    if (targetElement) {
      // Get the fixed header height dynamically
      const header = document.querySelector('.header');
      const headerHeight = header ? header.offsetHeight : 0;
      
      // Add extra padding for better visibility
      const extraPadding = 20;
      const totalOffset = headerHeight + extraPadding;
      
      // Calculate scroll position
      const elementPosition = targetElement.getBoundingClientRect().top;
      const offsetPosition = elementPosition + window.pageYOffset - totalOffset;
      
      console.log('[TOC] Scrolling to:', href, 'Header height:', headerHeight, 'Total offset:', totalOffset);
      
      // Scroll to the calculated position
      window.scrollTo({
        top: offsetPosition,
        behavior: 'smooth'
      });
      
      // Update URL hash
      if (window.history?.replaceState) {
        window.history.replaceState(null, null, href);
      }
      
      // Update active link after scroll completes
      setTimeout(() => this.updateActiveLink(), 600);
    }
  }

  updateActiveLink() {
    if (!this.headings.length || !this.tocLinks) return;

    const scrollTop = window.scrollY;
    const viewportHeight = window.innerHeight;
    
    // Find the currently visible heading
    let activeHeading = null;
    
    // Check if we're at the bottom of the page
    if (scrollTop + viewportHeight >= document.documentElement.scrollHeight - 10) {
      activeHeading = this.headings[this.headings.length - 1];
    } else {
      // Find the heading that's currently in view or just passed
      for (let i = this.headings.length - 1; i >= 0; i--) {
        if (scrollTop >= this.headings[i].top - 150) {
          activeHeading = this.headings[i];
          break;
        }
      }
    }

    // Update active link
    if (activeHeading) {
      const activeLink = this.tocSidebar?.querySelector(`[data-slug="${activeHeading.id}"]`);
      
      if (activeLink !== this.currentActiveLink) {
        // Remove previous active state
        this.currentActiveLink?.classList.remove('active');
        
        // Add new active state
        activeLink?.classList.add('active');
        this.currentActiveLink = activeLink;
        
        // Scroll the TOC to show the active item
        this.scrollTocToActiveItem(activeLink);
      }
    }
  }

  scrollTocToActiveItem(activeLink) {
    if (!activeLink || !this.tocScrollArea) return;

    const containerRect = this.tocScrollArea.getBoundingClientRect();
    const linkRect = activeLink.getBoundingClientRect();
    
    if (linkRect.top < containerRect.top || linkRect.bottom > containerRect.bottom) {
      const scrollTop = this.tocScrollArea.scrollTop;
      const linkOffsetTop = activeLink.offsetTop;
      const containerHeight = this.tocScrollArea.clientHeight;
      
      this.tocScrollArea.scrollTo({
        top: linkOffsetTop - containerHeight / 2,
        behavior: 'smooth'
      });
    }
  }

  updateScrollProgress() {
    if (!this.tocProgressFill) return;

    const scrollTop = window.scrollY;
    const documentHeight = document.documentElement.scrollHeight - window.innerHeight;
    const scrollPercentage = Math.min(100, Math.max(0, (scrollTop / documentHeight) * 100));
    
    this.tocProgressFill.style.width = `${scrollPercentage}%`;
  }
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    new TableOfContentsManager();
  });
} else {
  new TableOfContentsManager();
}
</script>
