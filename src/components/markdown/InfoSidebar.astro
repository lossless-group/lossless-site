---
import AuthorHandle from '@components/basics/AuthorHandle.astro';
import TagChip from '@components/tool-components/TagChip.astro';
import { formatDate } from '@utils/formatDate';

// Type definitions for trademarks data
type TrademarkEntry = Record<string, string>;
interface AugmenterTrademarks {
  [key: string]: TrademarkEntry[];
}

// Import the trademarks data from JSON file
import trademarksData from '@content/metadata/ai-augmenter-trademarks.json';

// Type assertion for the imported data
const trademarks: AugmenterTrademarks = trademarksData;

// Helper function to find trademark image URL with flexible matching
function findTrademarkImage(augmenterName: string | undefined): string | null {
  if (!augmenterName) return null;
  
  // Try exact match first
  let augmenterData = trademarks[augmenterName];
  
  // If no exact match, try to find a partial match
  if (!augmenterData) {
    const matchingKey = Object.keys(trademarks).find(key => 
      augmenterName?.toLowerCase().includes(key.toLowerCase()) || 
      key.toLowerCase().includes(augmenterName.toLowerCase())
    );
    
    if (matchingKey) {
      augmenterData = trademarks[matchingKey];
    } else {
      return null;
    }
  }
  
  if (!Array.isArray(augmenterData) || augmenterData.length === 0) {
    return null;
  }
  
  // First try to find a trademark entry
  let trademarkEntry = augmenterData.find(item => {
    const value = Object.values(item)[0];
    return value && typeof value === 'string' && value.toLowerCase().includes('trademark');
  });
  
  // If no trademark entry found, just take the first available image
  if (!trademarkEntry && augmenterData.length > 0) {
    trademarkEntry = augmenterData[0];
  }
  
  if (!trademarkEntry) return null;
  
  const value = Object.values(trademarkEntry)[0];
  return typeof value === 'string' ? value : null;
}

interface Props {
  categories?: string[];
  semanticVersion?: string;
  authorForHandle?: string | string[];
  participants?: string | string[];
  augmentedWith?: string;
  augmentedBy?: string;
  augmented_with?: string;
  augmented_by?: string;
  formattedDateModified?: string | null;
  formattedDateCreated?: string | null;
  formattedDateOfEvent?: string | null;
  tags?: string[];
  id?: string;
  path?: string;
  contentType?: string;
  google_maps_url?: string;
  googleMapsUrl?: string;
}

// Process component props
const {
  categories = [],
  semanticVersion,
  authorForHandle,
  participants,
  formattedDateModified,
  formattedDateCreated,
  formattedDateOfEvent,
  tags = [],
  id,
  path,
  contentType,
  google_maps_url,
  googleMapsUrl,
  ...restProps
} = Astro.props as Props;



// Handle all possible variations of the augmented with/by property
const augmentedWith = 
  restProps.augmented_with || 
  restProps.augmentedWith || 
  restProps.augmented_by || 
  restProps.augmentedBy;

// Process the augmented with data
const augmentedWithData = augmentedWith ? {
  name: augmentedWith,
  imageUrl: findTrademarkImage(augmentedWith)
} : null;

// Process Google Maps URL
console.log('[InfoSidebar] Received props - google_maps_url:', google_maps_url);
console.log('[InfoSidebar] Received props - googleMapsUrl:', googleMapsUrl);
const mapsUrl = google_maps_url || googleMapsUrl;
console.log('[InfoSidebar] Final mapsUrl:', mapsUrl);
const hasLocationInfo = Boolean(mapsUrl);
---

<aside class="info-sidebar" id="info-sidebar">
  <div class="info-header">
    <h2 class="info-title">Article Info</h2>
    <button class="info-collapse-btn" aria-label="Collapse Info Sidebar">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="9,18 15,12 9,6"></polyline>
      </svg>
    </button>
  </div>
  
  <div class="info-scroll-area" id="info-scroll-area">
    <div class="info-list">
      {categories.length > 0 && (
        <div class="categories-container">
          <div class="categories-wrapper">
            {categories.map(category => (
              <span class="category-pill">
                {category}
              </span>
            ))}
          </div>
          <div class="title-separator"></div>
        </div>
      )}

<div class="publish-info">
      {semanticVersion && (
        <div class="version-number">
          v.{semanticVersion}
        </div>
      )}



    {(formattedDateOfEvent || formattedDateModified || formattedDateCreated) && (
      <div class="text-xs">
        {formattedDateOfEvent ? (
          <!-- Event date takes priority and is centered -->
          <div class="text-center">
            <span class="date-label">Event Date</span>
            <div class="date-value">{formatDate(formattedDateOfEvent)}</div>
          </div>
        ) : (
          <!-- Standard two-column layout for Created/Updated -->
          <div class="flex justify-between">
            {formattedDateCreated && (
              <div>
                <span class="date-label">Created</span>
                <div class="date-value">{formatDate(formattedDateCreated)}</div>
              </div>
            )}
            {formattedDateModified && (
              <div class="text-right">
                <span class="date-label">Updated</span>
                <div class="date-value">{formatDate(formattedDateModified)}</div>
              </div>
            )}
          </div>
        )}
      </div>
    )}
</div>

    {hasLocationInfo && (
      <div class="location-info">
        <div class="location-separator"></div>
        <div>
          <span class="date-label">Location</span>
          <div class="location-content" data-maps-url={mapsUrl}>
            <div class="location-loading">Loading location...</div>
            <div class="location-display" style="display: none;">
              <div class="location-address"></div>
              <a class="location-link" href={mapsUrl} target="_blank" rel="noopener noreferrer">
                View on Google Maps
              </a>
            </div>
            <div class="location-error" style="display: none;">
              <a href={mapsUrl} target="_blank" rel="noopener noreferrer">View on Google Maps</a>
            </div>
          </div>
        </div>
      </div>
    )}

<div class="author-info">
      <div class="author-separator"></div>
      {authorForHandle ? (
        <div>
          <span class="date-label">Author</span>
          <AuthorHandle authors={authorForHandle} showName={true} showRole={false} alternateLayout={true} />
        </div>
      ) : participants ? (
        <div>
          <span class="date-label">Participants</span>
          <AuthorHandle authors={participants} showName={true} showRole={false} alternateLayout={true} />
        </div>
      ) : null}
      {augmentedWithData && (
        <div class="mt-2 w-[80%] ml-auto">
          <span class="augmented-with">Augmented with</span>
          <div class="augmented-with-content">
            {augmentedWithData.imageUrl ? (
              <img 
                src={augmentedWithData.imageUrl}
                alt={augmentedWithData.name}
                class="w-full h-auto max-h-8 object-contain"
                loading="lazy"
                title={augmentedWithData.name}
              />
            ) : (
              <span class="date-value">{augmentedWithData.name}</span>
            )}
          </div>
        </div>
      )}
    </div>

      {tags.length > 0 && (
        <div class="mt-4 flex flex-wrap justify-end gap-2">
          {tags.map(tag => (
            <TagChip tagString={tag} />
          ))}
        </div>
      )}
    </div>
  </div>
</aside>

<style>
/* ===== Modern Info Sidebar Styles (matching TableOfContents) ===== */

.info-sidebar {
  margin-right: 1rem;
  min-width: 280px;
  max-width: 320px;
  width: 320px;
  position: sticky;
  top: 2rem;
  align-self: flex-start;
  max-height: calc(100vh - 4rem);
  display: flex;
  flex-direction: column;
  background: rgba(0, 0, 0, 0.3);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
  transition: all 0.3s ease;
}

.info-sidebar:hover:not(.collapsed) {
  border-color: var(--clr-lossless-accent--brightest);
  box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
  width: 800px;
  max-width: 800px;
}

.info-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  background: rgba(255, 255, 255, 0.05);
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.info-title {
  font-size: 0.9rem;
  font-weight: 600;
  margin: 0;
  color: var(--clr-lossless-accent--brightest);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.info-collapse-btn {
  background: none;
  border: none;
  color: var(--clr-lossless-primary-light);
  cursor: pointer;
  padding: 4px;
  border-radius: 6px;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.info-collapse-btn:hover {
  background: rgba(255, 255, 255, 0.1);
  color: var(--clr-lossless-accent--brightest);
  transform: translateY(-1px);
}

.info-scroll-area {
  overflow-y: auto;
  flex-grow: 1;
  padding: 0.75rem 0;
  scrollbar-width: thin;
  scrollbar-color: var(--clr-lossless-accent--brightest) transparent;
}

.info-scroll-area::-webkit-scrollbar {
  width: 4px;
}

.info-scroll-area::-webkit-scrollbar-track {
  background: transparent;
}

.info-scroll-area::-webkit-scrollbar-thumb {
  background: var(--clr-lossless-accent--brightest);
  border-radius: 2px;
}

/* Categories and separator */
.categories-container {
  margin-bottom: 0.75rem;
}

.categories-wrapper {
  display: flex;
  justify-content: flex-end;
  flex-wrap: wrap;
  gap: 0.25rem;
  margin-bottom: 0.5rem;
}

.category-pill {
  display: inline-block;
  font-size: 0.75rem;
  font-weight: 500;
  color: white;
  background-color: var(--clr-lossless-attn-action, var(--purple-heart));
  padding: 0.25rem 0.5rem;
  border-radius: 0.125rem;
  line-height: 1;
}

.title-separator {
  height: 1px;
  background-color: var(--clr-lossless-accent--brightest);
  width: 100%;
}

.info-list {
  list-style: none;
  padding: 0 1.25rem;
  margin: 0;
  color: var(--clr-lossless-primary-light);
}

.info-list > div {
  margin: 0.4rem 0;
  line-height: 1.35;
  word-break: break-word;
}

/* Style for version number */
.version-number {
  text-align: center;
  margin: 0.5rem 0 1rem;
  font-size: 0.8rem;
  opacity: 0.8;
}

/* Remove default margin from first element after categories */
.categories-container + div:not(.version-number) {
  margin-top: 0;
}

/* Make the Perplexity logo much smaller */
.info-list img[src*="perplexity"] {
  max-width: 80px;
  height: auto;
  margin: 0.25rem 0 0.5rem 0;
  opacity: 0.9;
}

/* Adjust author section */
.author-handle-container {
  margin: 0.5rem 0;
}

/* Date styling */
.info-list .text-xs {
  font-size: 0.8rem;
  width: 100%;
}

.date-label {
  font-size: 0.6rem;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  opacity: 0.7;
  display: block;
  margin-bottom: 0.1rem;
}

.date-value {
  font-size: 0.8rem;
  opacity: 0.9;
  line-height: 1.2;
}

/* Augmented with section */
.augmented-with {
  display: block;
  text-align: right;
  font-size: 0.6rem;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  opacity: 0.7;
  margin-bottom: 0.1rem;
}

.augmented-with-content {
  text-align: right;
  margin-top: 0.1rem;
}

/* Location info section */
.location-info {
  margin: 1.25rem 0;
  padding: 0.75rem 0 0;
  position: relative;
}

.location-separator {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 1px;
  background-color: var(--clr-lossless-accent--brightest);
  opacity: 0.2;
}

.location-content {
  margin-top: 0.1rem;
}

.location-loading {
  font-size: 0.8rem;
  opacity: 0.7;
  font-style: italic;
}

.location-name {
  font-size: 0.8rem;
  font-weight: 500;
  margin-bottom: 0.2rem;
  opacity: 0.9;
}

.location-address {
  font-size: 0.75rem;
  opacity: 0.7;
  margin-bottom: 0.4rem;
  line-height: 1.2;
}

.location-link {
  display: inline-flex;
  align-items: center;
  gap: 0.3rem;
  font-size: 0.7rem;
  color: var(--clr-lossless-accent--brightest);
  text-decoration: none;
  opacity: 0.8;
  transition: opacity 0.2s ease;
}

.location-link:hover {
  opacity: 1;
  text-decoration: underline;
}

.location-link svg {
  flex-shrink: 0;
}

.location-error {
  font-size: 0.75rem;
  opacity: 0.7;
}

.location-photo {
  margin-bottom: 0.5rem;
}

.location-photo-img {
  width: 100%;
  max-width: 200px;
  height: auto;
  border-radius: 4px;
  object-fit: cover;
}

.location-details {
  margin: 0.4rem 0;
  font-size: 0.7rem;
}

.location-rating {
  display: flex;
  align-items: center;
  gap: 0.3rem;
  margin-bottom: 0.2rem;
}

.rating-stars {
  color: #fbbf24;
  font-size: 0.8rem;
}

.rating-text {
  opacity: 0.7;
}

.location-hours {
  opacity: 0.7;
  font-size: 0.65rem;
}

.location-error a {
  color: var(--clr-lossless-accent--brightest);
  text-decoration: none;
}

.location-error a:hover {
  text-decoration: underline;
}

.location-link {
  display: inline-block;
  color: var(--clr-lossless-accent--bright);
  text-decoration: none;
  margin-top: 4px;
  font-size: 0.9em;
  transition: color 0.2s ease;
}

.location-link:hover {
  color: var(--clr-lossless-accent--brighter);
  text-decoration: underline;
}

.location-address {
  font-weight: 500;
  margin-bottom: 4px;
}

/* Author info section */
.author-info {
  margin: 1.25rem 0;
  padding: 0.75rem 0 0;
  position: relative;
}

.author-separator {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 1px;
  background-color: var(--clr-lossless-accent--brightest);
  opacity: 0.2;
}

/* Tag cloud container */
.mt-4.flex.flex-wrap.justify-end.gap-2 {
  margin: 1.25rem 0 0.5rem;
  padding-top: 0.75rem;
  border-top: 1px solid rgba(255, 255, 255, 0.1);
  gap: 0.25rem;
  line-height: 1;
}

/* Make individual tag chips more compact */
.mt-4.flex.flex-wrap.justify-end.gap-2 .tag-chip {
  margin: 0.1rem 0;
  padding: 0.1rem 0.4rem;
}

/* Adjust version number */
.info-list > div:has(> v) {
  font-size: 0.8rem;
  opacity: 0.9;
  margin: 0.3rem 0;
}

/* Ensure the image container takes full width and maintains aspect ratio */
.info-list > div > img {
  width: 100%;
  height: auto;
  max-height: 2.5rem;
  object-fit: contain;
  display: block;
}

/* Animation for collapse/expand */
.info-sidebar.collapsed {
  width: 60px;
  min-width: 60px;
  max-width: 60px;
}

.info-sidebar.collapsed .info-scroll-area {
  display: none;
}

.info-sidebar.collapsed .info-title {
  display: none;
}

.info-sidebar.collapsed .info-collapse-btn svg {
  transform: rotate(180deg);
}

/* Responsive design */
@media (max-width: 1200px) {
  .info-sidebar {
    min-width: 260px;
    max-width: 280px;
  }
}

@media (max-width: 1024px) {
  .info-sidebar {
    display: none;
  }
}

/* Focus styles for accessibility */
.info-collapse-btn:focus {
  outline: 2px solid var(--clr-lossless-accent--brightest);
  outline-offset: 2px;
}
</style>

<script>
class InfoSidebarManager {
  infoSidebar;
  collapseBtn;

  constructor() {
    this.infoSidebar = document.getElementById('info-sidebar');
    this.collapseBtn = this.infoSidebar?.querySelector('.info-collapse-btn');
    
    if (this.infoSidebar) {
      this.init();
    }
  }

  init() {
    console.log('[InfoSidebar] Initializing InfoSidebarManager');
    this.setupEventListeners();
    this.initializeLocationInfo();
  }

  setupEventListeners() {
    // Collapse/expand functionality
    this.collapseBtn?.addEventListener('click', () => {
      this.toggleCollapse();
    });
  }

  toggleCollapse() {
    this.infoSidebar?.classList.toggle('collapsed');
    
    // Update aria-label for horizontal collapse
    const isCollapsed = this.infoSidebar?.classList.contains('collapsed');
    if (this.collapseBtn) {
      this.collapseBtn.setAttribute('aria-label', 
        isCollapsed ? 'Expand Info Sidebar' : 'Collapse Info Sidebar'
      );
    }
  }

  async initializeLocationInfo() {
    // Wait a bit for DOM to be fully ready
    await new Promise(resolve => setTimeout(resolve, 100));
    
    const locationContent = document.querySelector('.location-content[data-maps-url]') as HTMLElement | null;
    if (!locationContent) return;
    
    const mapsUrl = locationContent.getAttribute('data-maps-url');
    if (!mapsUrl) return;

    const linkElement = locationContent.querySelector('.location-link') as HTMLAnchorElement | null;
    const addressElement = locationContent.querySelector('.location-address');
    const displayElement = locationContent.querySelector('.location-display') as HTMLElement | null;
    const loadingElement = locationContent.querySelector('.location-loading') as HTMLElement | null;

    if (!linkElement || !addressElement || !displayElement || !loadingElement) return;

    try {
      // Set up the link
      linkElement.href = mapsUrl;
      linkElement.textContent = 'View on Google Maps';

      // Make API call to get the formatted address
      try {
        // Make sure to encode the URL parameter
        const apiUrl = new URL('/api/google-maps', window.location.origin);
        apiUrl.search = new URLSearchParams({ url: mapsUrl }).toString();
        
        console.log('[InfoSidebar] Fetching location data from:', apiUrl.toString());
        const response = await fetch(apiUrl.toString(), {
          headers: {
            'Content-Type': 'application/json',
          },
        });
        
        if (response.ok) {
          const result = await response.json();
          
          if (result.success && result.data && result.data.formatted_address) {
            // Use the formatted address from the API response
            addressElement.textContent = result.data.formatted_address;
          } else {
            // Fallback to showing just the link if no formatted address is available
            (addressElement as HTMLElement).style.display = 'none';
          }
        } else {
          // If API call fails, hide the address element
          (addressElement as HTMLElement).style.display = 'none';
        }
      } catch (error) {
        console.error('[InfoSidebar] Error fetching location data:', error);
        // Hide the address element on error
        (addressElement as HTMLElement).style.display = 'none';
      } finally {
        // Always show the display and hide loading, regardless of API success/failure
        (displayElement as HTMLElement).style.display = 'block';
        (loadingElement as HTMLElement).style.display = 'none';
      }
    } catch (error) {
      console.error('[InfoSidebar] Error processing maps URL:', error);
      // Fallback to just showing the link
      linkElement.textContent = 'View Location on Google Maps';
      (displayElement as HTMLElement).style.display = 'block';
      (loadingElement as HTMLElement).style.display = 'none';
    }
  }
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    new InfoSidebarManager();
  });
} else {
  new InfoSidebarManager();
}
</script>
