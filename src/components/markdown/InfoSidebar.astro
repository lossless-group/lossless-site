---
import AuthorHandle from '@components/basics/AuthorHandle.astro';
import TagChip from '@components/tool-components/TagChip.astro';
import { formatDate } from '@utils/formatDate';

// Type definitions for trademarks data
type TrademarkEntry = Record<string, string>;
interface AugmenterTrademarks {
  [key: string]: TrademarkEntry[];
}

// Import the trademarks data from JSON file
import trademarksData from '@content/metadata/ai-augmenter-trademarks.json';

// Type assertion for the imported data
const trademarks: AugmenterTrademarks = trademarksData;

// Helper function to find trademark image URL with flexible matching
function findTrademarkImage(augmenterName: string | undefined): string | null {
  if (!augmenterName) return null;
  
  // Try exact match first
  let augmenterData = trademarks[augmenterName];
  
  // If no exact match, try to find a partial match
  if (!augmenterData) {
    const matchingKey = Object.keys(trademarks).find(key => 
      augmenterName?.toLowerCase().includes(key.toLowerCase()) || 
      key.toLowerCase().includes(augmenterName.toLowerCase())
    );
    
    if (matchingKey) {
      augmenterData = trademarks[matchingKey];
    } else {
      return null;
    }
  }
  
  if (!Array.isArray(augmenterData) || augmenterData.length === 0) {
    return null;
  }
  
  // First try to find a trademark entry
  let trademarkEntry = augmenterData.find(item => {
    const value = Object.values(item)[0];
    return value && typeof value === 'string' && value.toLowerCase().includes('trademark');
  });
  
  // If no trademark entry found, just take the first available image
  if (!trademarkEntry && augmenterData.length > 0) {
    trademarkEntry = augmenterData[0];
  }
  
  if (!trademarkEntry) return null;
  
  const value = Object.values(trademarkEntry)[0];
  return typeof value === 'string' ? value : null;
}

interface Props {
  categories?: string[];
  semanticVersion?: string;
  authorForHandle?: string | string[];
  participants?: string | string[];
  augmentedWith?: string;
  augmentedBy?: string;
  augmented_with?: string;
  augmented_by?: string;
  formattedDateModified?: string | null;
  formattedDateCreated?: string | null;
  tags?: string[];
  id?: string;
  path?: string;
  contentType?: string;
}

// Process component props
const {
  categories = [],
  semanticVersion,
  authorForHandle,
  participants,
  formattedDateModified,
  formattedDateCreated,
  tags = [],
  id,
  path,
  contentType,
  ...restProps
} = Astro.props as Props;

// Debug logging
console.log('InfoSidebar Debug:');
console.log('authorForHandle:', authorForHandle);
console.log('participants:', participants);

// Handle all possible variations of the augmented with/by property
const augmentedWith = 
  restProps.augmented_with || 
  restProps.augmentedWith || 
  restProps.augmented_by || 
  restProps.augmentedBy;

// Process the augmented with data
const augmentedWithData = augmentedWith ? {
  name: augmentedWith,
  imageUrl: findTrademarkImage(augmentedWith)
} : null;
---

<aside class="info-sidebar" id="info-sidebar">
  <div class="info-header">
    <h2 class="info-title">Article Info</h2>
    <button class="info-collapse-btn" aria-label="Collapse Info Sidebar">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="9,18 15,12 9,6"></polyline>
      </svg>
    </button>
  </div>
  
  <div class="info-scroll-area" id="info-scroll-area">
    <div class="info-list">
      {categories.length > 0 && (
        <div class="categories-container">
          <div class="categories-wrapper">
            {categories.map(category => (
              <span class="category-pill">
                {category}
              </span>
            ))}
          </div>
          <div class="title-separator"></div>
        </div>
      )}

<div class="publish-info">
      {semanticVersion && (
        <div class="version-number">
          v.{semanticVersion}
        </div>
      )}



    {(formattedDateModified || formattedDateCreated) && (
      <div class="text-xs">
        <div class="flex justify-between">
          {formattedDateCreated && (
            <div>
              <span class="date-label">Created</span>
              <div class="date-value">{formatDate(formattedDateCreated)}</div>
            </div>
          )}
          {formattedDateModified && (
            <div class="text-right">
              <span class="date-label">Updated</span>
              <div class="date-value">{formatDate(formattedDateModified)}</div>
            </div>
          )}
        </div>
      </div>
    )}
</div>

<div class="author-info">
      <div class="author-separator"></div>
      {authorForHandle ? (
        <div>
          <span class="date-label">Author</span>
          <AuthorHandle authors={authorForHandle} showName={true} showRole={false} />
        </div>
      ) : participants ? (
        <div>
          <span class="date-label">Participants</span>
          <AuthorHandle authors={participants} showName={true} showRole={false} />
        </div>
      ) : null}
      {augmentedWithData && (
        <div class="mt-2 w-[80%] ml-auto">
          <span class="augmented-with">Augmented with</span>
          <div class="augmented-with-content">
            {augmentedWithData.imageUrl ? (
              <img 
                src={augmentedWithData.imageUrl}
                alt={augmentedWithData.name}
                class="w-full h-auto max-h-8 object-contain"
                loading="lazy"
                title={augmentedWithData.name}
              />
            ) : (
              <span class="date-value">{augmentedWithData.name}</span>
            )}
          </div>
        </div>
      )}
    </div>

      {tags.length > 0 && (
        <div class="mt-4 flex flex-wrap justify-end gap-2">
          {tags.map(tag => (
            <TagChip tagString={tag} />
          ))}
        </div>
      )}
    </div>
  </div>
</aside>

<style>
/* ===== Modern Info Sidebar Styles (matching TableOfContents) ===== */

.info-sidebar {
  margin-right: 1rem;
  min-width: 280px;
  max-width: 320px;
  width: 320px;
  position: sticky;
  top: 2rem;
  align-self: flex-start;
  max-height: calc(100vh - 4rem);
  display: flex;
  flex-direction: column;
  background: rgba(0, 0, 0, 0.3);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
  transition: all 0.3s ease;
}

.info-sidebar:hover:not(.collapsed) {
  border-color: var(--clr-lossless-accent--brightest);
  box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
  width: 800px;
  max-width: 800px;
}

.info-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.25rem;
  background: rgba(255, 255, 255, 0.05);
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.info-title {
  font-size: 0.9rem;
  font-weight: 600;
  margin: 0;
  color: var(--clr-lossless-accent--brightest);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.info-collapse-btn {
  background: none;
  border: none;
  color: var(--clr-lossless-primary-light);
  cursor: pointer;
  padding: 4px;
  border-radius: 6px;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.info-collapse-btn:hover {
  background: rgba(255, 255, 255, 0.1);
  color: var(--clr-lossless-accent--brightest);
  transform: translateY(-1px);
}

.info-scroll-area {
  overflow-y: auto;
  flex-grow: 1;
  padding: 0.75rem 0;
  scrollbar-width: thin;
  scrollbar-color: var(--clr-lossless-accent--brightest) transparent;
}

.info-scroll-area::-webkit-scrollbar {
  width: 4px;
}

.info-scroll-area::-webkit-scrollbar-track {
  background: transparent;
}

.info-scroll-area::-webkit-scrollbar-thumb {
  background: var(--clr-lossless-accent--brightest);
  border-radius: 2px;
}

/* Categories and separator */
.categories-container {
  margin-bottom: 0.75rem;
}

.categories-wrapper {
  display: flex;
  justify-content: flex-end;
  flex-wrap: wrap;
  gap: 0.25rem;
  margin-bottom: 0.5rem;
}

.category-pill {
  display: inline-block;
  font-size: 0.75rem;
  font-weight: 500;
  color: white;
  background-color: var(--clr-lossless-attn-action, var(--purple-heart));
  padding: 0.25rem 0.5rem;
  border-radius: 0.125rem;
  line-height: 1;
}

.title-separator {
  height: 1px;
  background-color: var(--clr-lossless-accent--brightest);
  width: 100%;
}

.info-list {
  list-style: none;
  padding: 0 1.25rem;
  margin: 0;
  color: var(--clr-lossless-primary-light);
}

.info-list > div {
  margin: 0.4rem 0;
  line-height: 1.35;
  word-break: break-word;
}

/* Style for version number */
.version-number {
  text-align: center;
  margin: 0.5rem 0 1rem;
  font-size: 0.8rem;
  opacity: 0.8;
}

/* Remove default margin from first element after categories */
.categories-container + div:not(.version-number) {
  margin-top: 0;
}

/* Make the Perplexity logo much smaller */
.info-list img[src*="perplexity"] {
  max-width: 80px;
  height: auto;
  margin: 0.25rem 0 0.5rem 0;
  opacity: 0.9;
}

/* Adjust author section */
.author-handle-container {
  margin: 0.5rem 0;
}

/* Date styling */
.info-list .text-xs {
  font-size: 0.8rem;
  width: 100%;
}

.date-label {
  font-size: 0.6rem;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  opacity: 0.7;
  display: block;
  margin-bottom: 0.1rem;
}

.date-value {
  font-size: 0.8rem;
  opacity: 0.9;
  line-height: 1.2;
}

/* Augmented with section */
.augmented-with {
  display: block;
  text-align: right;
  font-size: 0.6rem;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  opacity: 0.7;
  margin-bottom: 0.1rem;
}

.augmented-with-content {
  text-align: right;
  margin-top: 0.1rem;
}

/* Author info section */
.author-info {
  margin: 1.25rem 0;
  padding: 0.75rem 0 0;
  position: relative;
}

.author-separator {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 1px;
  background-color: var(--clr-lossless-accent--brightest);
  opacity: 0.2;
}

/* Tag cloud container */
.mt-4.flex.flex-wrap.justify-end.gap-2 {
  margin: 1.25rem 0 0.5rem;
  padding-top: 0.75rem;
  border-top: 1px solid rgba(255, 255, 255, 0.1);
  gap: 0.25rem;
  line-height: 1;
}

/* Make individual tag chips more compact */
.mt-4.flex.flex-wrap.justify-end.gap-2 .tag-chip {
  margin: 0.1rem 0;
  padding: 0.1rem 0.4rem;
}

/* Adjust version number */
.info-list > div:has(> v) {
  font-size: 0.8rem;
  opacity: 0.9;
  margin: 0.3rem 0;
}

/* Ensure the image container takes full width and maintains aspect ratio */
.info-list > div > img {
  width: 100%;
  height: auto;
  max-height: 2.5rem;
  object-fit: contain;
  display: block;
}

/* Animation for collapse/expand */
.info-sidebar.collapsed {
  width: 48px;
  min-width: 48px;
  max-width: 48px;
}

.info-sidebar.collapsed .info-scroll-area {
  display: none;
}

.info-sidebar.collapsed .info-title {
  display: none;
}

.info-sidebar.collapsed .info-collapse-btn svg {
  transform: rotate(180deg);
}

/* Responsive design */
@media (max-width: 1200px) {
  .info-sidebar {
    min-width: 260px;
    max-width: 280px;
  }
}

@media (max-width: 1024px) {
  .info-sidebar {
    display: none;
  }
}

/* Focus styles for accessibility */
.info-collapse-btn:focus {
  outline: 2px solid var(--clr-lossless-accent--brightest);
  outline-offset: 2px;
}
</style>

<script>
class InfoSidebarManager {
  constructor() {
    this.infoSidebar = document.getElementById('info-sidebar');
    this.collapseBtn = this.infoSidebar?.querySelector('.info-collapse-btn');
    
    if (this.infoSidebar) {
      this.init();
    }
  }

  init() {
    console.log('[InfoSidebar] Initializing InfoSidebarManager');
    this.setupEventListeners();
  }

  setupEventListeners() {
    // Collapse/expand functionality
    this.collapseBtn?.addEventListener('click', () => {
      this.toggleCollapse();
    });
  }

  toggleCollapse() {
    this.infoSidebar?.classList.toggle('collapsed');
    
    // Update aria-label for horizontal collapse
    const isCollapsed = this.infoSidebar?.classList.contains('collapsed');
    if (this.collapseBtn) {
      this.collapseBtn.setAttribute('aria-label', 
        isCollapsed ? 'Expand Info Sidebar' : 'Collapse Info Sidebar'
      );
    }
  }
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    new InfoSidebarManager();
  });
} else {
  new InfoSidebarManager();
}
</script>
