---
import {dirname} from 'path'
import ArticleCallout from './callouts/ArticleCallout.astro';
import ArticleCitationsBlock from './citations/ArticleCitations.astro';
import ArticleCitation from './citations/ArticleCitation.astro';
import BaseCodeblock from '../codeblocks/BaseCodeblock.astro';
import MermaidChart from '../codeblocks/MermaidChart.astro';
import ImageGallery from './ImageGallery.astro';
import ToolingGallery from './ToolingGallery.astro';
import { getCollection } from "astro:content";
import { DEBUG_AST } from '@utils/envUtils';
import { slugify, extractAllText } from '@utils/slugify';
import CopyLinkButton from './CopyLinkButton.astro';
import { resolveToolId } from '@utils/toolUtils';
/*
      Compose a unique id for markdown headings using ONLY the main heading text.
      - This function takes a heading MDAST node and returns a slugified version of the primary text content.
      - It does NOT include the file name, any prefix, or subtitle/lead-in text.
      - Example: 'A Parable of Directionality' → 'a-parable-of-directionality'
      - This logic matches ToC anchor links for in-page navigation.
      - Aggressively commented: update here and at all call sites if logic changes.
    */
    // Extract only the first text node (primary heading text)


interface Props {
    /**
     * Markdown AST node interface for AstroMarkdown.astro
     * - 'lang' is present on 'code' nodes and specifies the code language (e.g., 'js', 'python').
     * - See remark/rehype AST docs for more details.
     */
    node: {
        type: string;
        value?: string;
        lang?: string; // <-- Added for code blocks
        children?: any[];
        url?: string;
        depth?: number;
        data?: {
            hProperties?: Record<string, any>;
            map?: any[];
        };
        label?: string;
        meta?: string;
    };
    data: {
        path: string;
        id?: string;  // File ID (e.g., 'Agile.md')
        [key: string]: any;
    };
}

const { node, data } = Astro.props;



// List of node types we handle with specific components
// Order matters! Container types (like blockquote) should be handled before their children (like paragraph)
const handled_types = [
    "root",
    "link",        // Handle standard MDAST link nodes
    "blockquote",  // Handle blockquotes before paragraphs since they contain paragraphs
    "paragraph",
    "text",
    "heading",
    "image",
    "list",
    "listItem",
    "code",
    "inlineCode",
    "table",
    "tableRow",
    "tableCell",
    "strong",
    "emphasis",
    "break",
    "html",
    "citation",
    "citations",
    "citationReference",
    "footnoteReference",
    "footnoteDefinition",    
    "tableOfContents",
    "imageGallery",
    "toolingGallery",
    "thematicBreak" // Add support for horizontal rules
]

const other_type = !handled_types.includes(node.type)
data.dirpath = dirname(data.path)


//This logic has to be done up here because it's async work
// Only apply if it's a toolGallery code block
  const isToolingGallery = (
    node.lang === 'toolingGallery' || (node.lang === 'yaml' && node.meta?.startsWith('toolingGallery'))
  );

  const isImageGallery = (
    node.lang === 'imageGallery' || (node.lang === 'yaml' && node.meta === 'imageGallery')
  );

let toolGalleryTools = null;
let toolGalleryErrors: string[] = [];
let isSmallToolGallery = false


if (isToolingGallery) {  
  isSmallToolGallery = node.meta?.includes('small');

  const rawLines = node.value
    .split('\n')
    .map(line => line.trim())
    .filter(Boolean);

  const tagFilters = [];
  const rawToolIds = [];

  for (const line of rawLines) {
    const tagMatch = line.match(/^- tag:\s*(?:\[\[(.*?)\]\]|(.*))/i);
    if (tagMatch) {
      tagFilters.push((tagMatch[1] ?? tagMatch[2]).trim());
      continue;
    }

    // Otherwise treat as tool reference
    const toolMatch = line.replace(/^- /, '').trim();
    if (toolMatch) {
      rawToolIds.push(toolMatch);
    }
  }

  // Load tooling collection
  const allTools = await getCollection('tooling');
  const toolMap = new Map(allTools.map(entry => [entry.id, {
    ...entry.data,
    id: entry.id,
    filePath: entry.id,
  }]));

  const tools = [];
  const toolGalleryErrors = [];

  console.log(toolMap.values().next().value);

  // Resolve toolIds
  for (const input of rawToolIds) {
    let id = input;

    const backlinkMatch = input.match(/^\[\[(?!.*?visuals)(.*?)(?:\|.*?)?\]\]$/);
    if (backlinkMatch) {
      id = backlinkMatch[1].trim();
    }

    const resolvedId = await resolveToolId(id, allTools);
    if (resolvedId && toolMap.has(resolvedId)) {
      tools.push(toolMap.get(resolvedId));
    } else {
      toolGalleryErrors.push(input);
    }
  }

  // Add tools matching tagFilters
  const normalizeTag = tag => slugify(tag).toLowerCase();

  if (tagFilters.length > 0) {
    const tagFilteredTools = allTools
      .filter(tool => tool.data.tags?.some(tag =>
        tagFilters.some(filterTag =>
          normalizeTag(filterTag) === normalizeTag(tag)
        )
      ))
      .map(entry => ({
        ...entry.data,
        id: entry.id,
        filePath: entry.id,
      }));
    
    // Add tag-matched tools if not already added
    for (const tool of tagFilteredTools) {
      if (!tools.some(t => t.id === tool.id)) {
        tools.push(tool);
      }
    }
  }

  if (toolGalleryErrors.length > 0) {
    console.warn('[toolingGallery] Missing tools for IDs:', toolGalleryErrors);
  }

  toolGalleryTools = tools;

}
// Debug output to see AST structure
if (DEBUG_AST) {
  console.log(`=== AstroMarkdown Debug ===`)
  console.log(`Node type: ${node.type}`)
  console.log('Node structure:', JSON.stringify(node, null, 2))
}
---

{node.type === "root" && (() => {
  return (
    <>
      {node.children.map((child) => (
          <Astro.self node={child} data={data} />
      ))}
    </>
  );
})()}

{node.type === "heading" && (() => {
  const currentHeaderText = extractAllText(node.children).trim() || 'Untitled Section';

  const generateHeadingId = nodeForId =>
    slugify(extractAllText(nodeForId.children).trim() || 'untitled-heading');
  const id = generateHeadingId(node);

  const content = (
    <>
      <span class="heading-text">
        {node.children.map(child => (
          <Astro.self node={child} data={data} />
        ))}
      </span>
      <CopyLinkButton id={id} label={currentHeaderText} />
    </>

    <style>
      .heading-with-copy {
        display: flex;
        align-items: center;
        gap: 0.2rem;
        flex-wrap: wrap;     
        max-width: 100%;
      }

      .heading-text {
        display: inline;
        line-height: inherit;
      }
    </style>
  );

  switch (node.depth) {
    case 1: return <h1 id={id} class="heading-with-copy">{content}</h1>;
    case 2: return <h2 id={id} class="heading-with-copy">{content}</h2>;
    case 3: return <h3 id={id} class="heading-with-copy">{content}</h3>;
    case 4: return <h4 id={id} class="heading-with-copy">{content}</h4>;
    case 5: return <h5 id={id} class="heading-with-copy">{content}</h5>;
    case 6: return <h6 id={id} class="heading-with-copy">{content}</h6>;
    default:
      return <div>{content}</div>;
  }
})()}


{(node.type === "strong") &&
  <strong>
    {node.children.map(child => (
      <Astro.self node={child} data={data} />
    ))}
  </strong>
}

{(node.type === "emphasis") &&
  <em>
    {node.children.map(child => (
      <Astro.self node={child} data={data} />
    ))}
  </em>
}


{(node.type === "image") &&
    <img src={node.url} />
}

{(node.type === "list") &&
  <>
    {node['ordered']
      ? <ol>
          {node.children.map((item) => (
            <Astro.self node={item} data={data} />
          ))}
        </ol>
      : <ul>
          {node.children.map((item) => (
            <Astro.self node={item} data={data} />
          ))}
        </ul>
    }
  </>
}

{(node.type === "listItem") &&
  <li class="custom-li">
    <span class="li-content">
      {node.children.map(child => (
        <Astro.self node={child} data={data} />
      ))}
    </span>
  </li>
}


{(node.type === "table") &&
  <div class="md-table-wrapper">
    <table class="md-table">
      <tbody>
        {node.children.map(row => (
          <Astro.self node={row} data={data} />
        ))}
      </tbody>
    </table>
  </div>
  <style>
     .md-table-wrapper {
        overflow-x: auto;
        margin-bottom: 1.5rem;
    }

    .md-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.95rem;
        background-color: transparent;
    }

    .md-tr:nth-child(even) {
        background-color: rgba(255, 255, 255, 0.03);
    }

    .md-td {
        border: 1px solid rgb(255, 255, 255);
        padding: 0.5rem 0.75rem;
        text-align: left;
        colrgb(255, 255, 255);
    }


  </style>
}

{(node.type === "tableRow") &&
  <tr class="md-tr">
    {node.children.map(cell => (
      <Astro.self node={cell} data={data} />
    ))}
  </tr>
}

{(node.type === "tableCell") &&
  <td class="md-td">
    {node.children.map(child => (
      <Astro.self node={child} data={data} />
    ))}
  </td>
}


{(node.type === "link") && 
    <a href={node.url} {...(node.data?.hProperties ?? {})}>
        {node.children[0].value}
    </a>
}

{node.type === "code" && (() => {
  const { lang, meta, value } = node;

  if (toolGalleryTools?.length > 0) {
      return (
          <>
            <ToolingGallery tools={toolGalleryTools} small={isSmallToolGallery}/>
            {toolGalleryErrors.length > 0 && (
              <div class="tool-gallery-error">
                ⚠️ Tool(s) not found:
                <ul>
                  {toolGalleryErrors.map(id => <li><code>{id}</code></li>)}
                </ul>
              </div>

              <style>
                .tool-gallery-error {
                    color: #ff6b6b;
                    background-color: rgba(255, 0, 0, 0.05);
                    border: 1px solid rgba(255, 0, 0, 0.2);
                    padding: 0.75rem;
                    margin-top: 2rem;
                    border-radius: 0.5rem;
                    font-size: 0.9rem;
                  }

                  .tool-gallery-error ul {
                    margin: 0.5rem 0 0;
                    padding-left: 1.25rem;
                  }
              </style>
            )}
          </>
      )}

  if (isImageGallery) {
    return <ImageGallery code={value} dirpath={data.dirpath} />;
  }

  if (lang === 'mermaid') {
    return <MermaidChart code={value} />;
  }

  return <BaseCodeblock code={value} lang={lang ?? 'text'} />;
})()}



{(node.type === "html") &&
  <div class="raw-html" set:html={node.value} />
}


{(node.type === "blockquote") &&
    <ArticleCallout node={node} />
}

{(node.type === "inlineCode") &&
  <code class="inline-code">{node.value}</code>
}

<!-- Anything citation-* is custom made -->
<!-- === citationReference === -->
{node.type === 'citationReference' && (
  <sup class="cite-ref">
    <a
      href={node.data?.hProperties?.href ?? ''}
      id={node.data?.hProperties?.id ?? ''}
      class="citation-link"
    >
      [{node.children?.map(child => <Astro.self node={child} data={data} />)}]
    </a>
  </sup>
)}

<!-- === single citation node === -->
{node.type === 'citation' && (
  <ArticleCitation node={node} />
)}

<!-- === citations block === -->
{node.type === 'citations' && (
  <ArticleCitationsBlock node={node} />
)}

<!-- footnoteReference and footnoteDefinition are from standard Markdown library -->
{node.type === 'footnoteReference' && (
  <sup class="footnote-ref">
    <a href={`#${node.label}`} id={`ref-${node.label}`}>
      [{node.label}]
    </a>
  </sup>
  <style>
  .footnote-ref {
    font-size: 0.6em;
    vertical-align: super;
    top: 0px;
  }

  .footnote-definition {
    font-size: 0.9em;
    margin-top: 1em;
    border-top: 1px solid #666;
    padding-top: 0.5em;
  }

</style>

)}

{node.type === 'footnoteDefinition' && (
  <div id={node.label} class="footnote-definition">
    {node.children.length === 1 && node.children[0].type === 'paragraph' ? (
      <p>
        <strong><a href={`#ref-${node.label}`}>[{node.label}]</a></strong>{' '}
        {node.children[0].children.map(child => (
          <Astro.self node={child} data={data} />
        ))}{' '}
      </p>
    ) : (
      <>
        <strong>[{node.label}]</strong>
        {node.children.map(child => (
          <Astro.self node={child} data={data} />
        ))}
      </>
    )}
  </div>
)}


{(node.type === "paragraph") &&
    <div class="paragraph">
        {node.children.map((child: any) => (
            <Astro.self node={child} data={data} />
        ))}
    </div>
}

{(node.type === "thematicBreak") && 
    <hr />
}

{(node.type === "text") && 
    <span>{node.value}</span>
}

{other_type && 
    <div class={`unhandled-${node.type}`}>
        {JSON.stringify(node)}
    </div>
}

