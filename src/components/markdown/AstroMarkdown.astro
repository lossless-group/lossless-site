---
import {dirname} from 'path'
import ArticleCallout from './callouts/ArticleCallout.astro';
import ArticleCitationsBlock from './citations/ArticleCitations.astro';
import ArticleCitation from './citations/ArticleCitation.astro';
import BaseCodeblock from '../codeblocks/BaseCodeblock.astro';
import MermaidChart from '../codeblocks/MermaidChart.astro';

interface Props {
    /**
     * Markdown AST node interface for AstroMarkdown.astro
     * - 'lang' is present on 'code' nodes and specifies the code language (e.g., 'js', 'python').
     * - See remark/rehype AST docs for more details.
     */
    node: {
        type: string;
        value?: string;
        lang?: string; // <-- Added for code blocks
        children?: any[];
        url?: string;
        depth?: number;
        data?: {
            hProperties?: Record<string, any>;
            map?: any[];
        };
        label?: string;
    };
    data: {
        path: string;
        id?: string;  // File ID (e.g., 'Agile.md')
        [key: string]: any;
    };
    compiledContent?: string;
}

const {node, data, compiledContent} = Astro.props;

// List of node types we handle with specific components
// Order matters! Container types (like blockquote) should be handled before their children (like paragraph)
const handled_types = [
    "root",
    "link",        // Handle standard MDAST link nodes
    "blockquote",  // Handle blockquotes before paragraphs since they contain paragraphs
    "paragraph",
    "text",
    "heading",
    "image",
    "list",
    "listItem",
    "code",
    "inlineCode",
    "table",
    "tableRow",
    "tableCell",
    "strong",
    "emphasis",
    "break",
    "html",
    "citation",
    "citations",
    "citationReference",
    "footnoteReference",
    "footnoteDefinition",    
    "tableOfContents",
    "thematicBreak" // Add support for horizontal rules
]

const other_type = !handled_types.includes(node.type)
data.dirpath = dirname(data.path)

// Extract title from file ID if available and convert to Title Case
const title = data.id ? 
  data.id
    .replace(/\.md$/, '')
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ')
  : '';

// Debug output to see AST structure
// console.log(`=== AstroMarkdown Debug ===`)
// console.log(`Node type: ${node.type}`)
// console.log('Node structure:', JSON.stringify(node, null, 2))

---

{node.type === "root" && 
  <>
    {data?.renderingToC !== true && <h1>{title}</h1>}
    {node.children.map((child) => (
        <Astro.self node={child} data={data} />
    ))}
  </>
}

{node.type === "heading" && (() => {
  function generateHeadingId(node, data) {
    // Compose a unique id using the heading text and file id (if available)
    const base = (Array.isArray(node.children)
      ? node.children.filter(child => child.type === 'text').map(child => child.value).join('')
      : '')
      .toLowerCase()
      .replace(/[^\w\s-]/g, '')
      .trim()
      .replace(/\s+/g, '-');
    // Add file id (without extension) as prefix if available
    const prefix = data?.id ? data.id.replace(/\.md$/, '') + '-' : '';
    return `${prefix}${base}`;
  }

  const id = generateHeadingId(node, data);

  if (node.depth === 1) {
    return <h1 id={id}>{node.children.map(child => <Astro.self node={child} data={data} />)}</h1>;
  } else if (node.depth === 2) {
    return <h2 id={id}>{node.children.map(child => <Astro.self node={child} data={data} />)}</h2>;
  } else if (node.depth === 3) {
    return <h3 id={id}>{node.children.map(child => <Astro.self node={child} data={data} />)}</h3>;
  } else if (node.depth === 4) {
    return <h4 id={id}>{node.children.map(child => <Astro.self node={child} data={data} />)}</h4>;
  } else if (node.depth === 5) {
    return <h5 id={id}>{node.children.map(child => <Astro.self node={child} data={data} />)}</h5>;
  } else if (node.depth === 6) {
    return <h6 id={id}>{node.children.map(child => <Astro.self node={child} data={data} />)}</h6>;
  } else {
    // Fallback for unexpected heading depths
    return <div>{node.children.map(child => <Astro.self node={child} data={data} />)}</div>;
  }
})()}

{(node.type === "strong") &&
  <strong>
    {node.children.map(child => (
      <Astro.self node={child} data={data} />
    ))}
  </strong>
}

{(node.type === "emphasis") &&
  <em>
    {node.children.map(child => (
      <Astro.self node={child} data={data} />
    ))}
  </em>
}


{(node.type === "image") &&
    <img src={node.url} />
}

{(node.type === "list") &&
  <>
    {node['ordered']
      ? <ol>
          {node.children.map((item) => (
            <Astro.self node={item} data={data} />
          ))}
        </ol>
      : <ul>
          {node.children.map((item) => (
            <Astro.self node={item} data={data} />
          ))}
        </ul>
    }
  </>
}

{(node.type === "listItem") &&
  <li class="custom-li">
    <span class="li-content">
      {node.children.map(child => (
        <Astro.self node={child} data={data} />
      ))}
    </span>
  </li>
}

{(node.type === "table") &&
  <div class="md-table-wrapper">
    <table class="md-table">
      <tbody>
        {node.children.map(row => (
          <Astro.self node={row} data={data} />
        ))}
      </tbody>
    </table>
  </div>
  <style>
     .md-table-wrapper {
        overflow-x: auto;
        margin-bottom: 1.5rem;
    }

    .md-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.95rem;
        background-color: transparent;
    }

    .md-tr:nth-child(even) {
        background-color: rgba(255, 255, 255, 0.03);
    }

    .md-td {
        border: 1px solid rgb(255, 255, 255);
        padding: 0.5rem 0.75rem;
        text-align: left;
        colrgb(255, 255, 255);
    }


  </style>
}

{(node.type === "tableRow") &&
  <tr class="md-tr">
    {node.children.map(cell => (
      <Astro.self node={cell} data={data} />
    ))}
  </tr>
}

{(node.type === "tableCell") &&
  <td class="md-td">
    {node.children.map(child => (
      <Astro.self node={child} data={data} />
    ))}
  </td>
}


{(node.type === "link") && 
    <a href={node.url} {...(node.data?.hProperties ?? {})}>
        {node.children[0].value}
    </a>
}

{(node.type === "code") && (
  node.lang === "mermaid"
    ? <MermaidChart code={node.value} />
    : <BaseCodeblock code={node.value} lang={node.lang ?? 'text'} />
)}

{(node.type === "html") &&
  <div class="raw-html" set:html={node.value} />
}


{(node.type === "blockquote") &&
    <ArticleCallout node={node} />
}

{(node.type === "inlineCode") &&
  <code class="inline-code">{node.value}</code>
}

<!-- Anything citation-* is custom made -->
<!-- === citationReference === -->
{node.type === 'citationReference' && (
  <sup class="cite-ref">
    <a
      href={node.data?.hProperties?.href ?? ''}
      id={node.data?.hProperties?.id ?? ''}
      class="citation-link"
    >
      [{node.children?.map(child => <Astro.self node={child} data={data} />)}]
    </a>
  </sup>
)}

<!-- === single citation node === -->
{node.type === 'citation' && (
  <ArticleCitation node={node} />
)}

<!-- === citations block === -->
{node.type === 'citations' && (
  <ArticleCitationsBlock node={node} />
)}

<!-- footnoteReference and footnoteDefinition are from standard Markdown library -->
{node.type === 'footnoteReference' && (
  <sup class="footnote-ref">
    <a href={`#${node.label}`} id={`ref-${node.label}`}>
      [{node.label}]
    </a>
  </sup>
  <style>
  .footnote-ref {
    font-size: 0.6em;
    vertical-align: super;
    top: 0px;
  }

  .footnote-definition {
    font-size: 0.9em;
    margin-top: 1em;
    border-top: 1px solid #666;
    padding-top: 0.5em;
  }

</style>

)}

{node.type === 'footnoteDefinition' && (
  <div id={node.label} class="footnote-definition">
    {node.children.length === 1 && node.children[0].type === 'paragraph' ? (
      <p>
        <strong><a href={`#ref-${node.label}`}>[{node.label}]</a></strong>{' '}
        {node.children[0].children.map(child => (
          <Astro.self node={child} data={data} />
        ))}{' '}
      </p>
    ) : (
      <>
        <strong>[{node.label}]</strong>
        {node.children.map(child => (
          <Astro.self node={child} data={data} />
        ))}
      </>
    )}
  </div>
)}

{node.type === "tableOfContents" && Array.isArray(node.data?.map) && node.data.map.length > 0 && (
  <aside class="toc-sidebar">
    {node.data.map.map((tocNode, i) => (
      <Astro.self node={tocNode} data={data} />
    ))}
    <style>
      .toc-sidebar {
        position: sticky;
        top: 4rem;
        max-height: calc(100vh - 4rem);
        overflow-y: auto;
        font-size: 0.9rem;
        padding-right: 1rem;
        margin-bottom: 2rem;
      }
      .toc-sidebar ul {
        list-style-type: none;
        padding-left: 0;
      }
      .toc-sidebar li {
        margin: 0.3rem 0;
      }
      .toc-sidebar a {
        text-decoration: none;
        color: #ccc;
      }
      .toc-sidebar a:hover {
        color: white;
      }
    </style>
  </aside>
)}
{node.type === "tableOfContents" && (!Array.isArray(node.data?.map) || node.data.map.length === 0) && (
  <aside class="toc-sidebar">
    <h1>{data?.id ? data.id.replace(/\.md$/, '') : 'Untitled'}</h1>
    <style>
      .toc-sidebar {
        position: sticky;
        top: 4rem;
        max-height: calc(100vh - 4rem);
        overflow-y: auto;
        font-size: 0.9rem;
        padding-right: 1rem;
        margin-bottom: 2rem;
      }
      .toc-sidebar ul {
        list-style-type: none;
        padding-left: 0;
      }
      .toc-sidebar li {
        margin: 0.3rem 0;
      }
      .toc-sidebar a {
        text-decoration: none;
        color: #ccc;
      }
      .toc-sidebar a:hover {
        color: white;
      }
    </style>
  </aside>
)}

{(node.type === "paragraph") &&
    <div class="paragraph">
        {node.children.map((child: any) => (
            <Astro.self node={child} data={data} />
        ))}
    </div>
}

{(node.type === "thematicBreak") && 
    <hr />
}

{(node.type === "text") && 
    <span>{node.value}</span>
}

{other_type && 
    <div class={`unhandled-${node.type}`}>
        {JSON.stringify(node)}
    </div>
}