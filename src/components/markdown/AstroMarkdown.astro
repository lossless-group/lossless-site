---
import {dirname} from 'path'
import ArticleCallout from './callouts/ArticleCallout.astro';
import ArticleCitationsBlock from './citations/ArticleCitations.astro';
import ArticleCitation from './citations/ArticleCitation.astro';
import MermaidChart from '../codeblocks/MermaidChart.astro';
import BaseCodeblock from '../codeblocks/BaseCodeblock.astro';
import ImageGallery from './ImageGallery.astro';
import ToolingGallery from './ToolingGallery.astro';
import PortfolioGallery from '@components/tool-components/PortfolioGallery.astro';
import CopyLinkButton from './CopyLinkButton.astro';
import { getLanguageRoutingStrategy, isSpecialRendererLanguage } from '../../utils/shikiHighlighter.js';
import SlidesEmbed from '@components/SlidesEmbed.astro';
import ToolShowcaseIsland from '@components/toolkit/ToolShowcaseIsland.astro';
import { getCollection } from "astro:content";
import { DEBUG_AST } from '@utils/envUtils';
import { slugify, extractAllText } from '@utils/slugify';
import { resolveToolId, resolvePortfolioId } from '@utils/toolUtils';
/*
      Compose a unique id for markdown headings using ONLY the main heading text.
      - This function takes a heading MDAST node and returns a slugified version of the primary text content.
      - It does NOT include the file name, any prefix, or subtitle/lead-in text.
      - Example: 'A Parable of Directionality' → 'a-parable-of-directionality'
      - This logic matches ToC anchor links for in-page navigation.
      - Aggressively commented: update here and at all call sites if logic changes.
    */
    // Extract only the first text node (primary heading text)


interface Props {
    /**
     * Markdown AST node interface for AstroMarkdown.astro
     * - 'lang' is present on 'code' nodes and specifies the code language (e.g., 'js', 'python').
     * - See remark/rehype AST docs for more details.
     */
    node: {
        type: string;
        value?: string;
        lang?: string; // <-- Added for code blocks
        children?: any[];
        url?: string;
        depth?: number;
        data?: {
            hProperties?: Record<string, any>;
            map?: any[];
        };
        label?: string;
        meta?: string;
        // Directive-specific properties
        name?: string; // directive name (e.g., 'figma-embed')
        attributes?: Record<string, any>; // directive attributes
    };
    data: {
        path: string;
        id?: string;  // File ID (e.g., 'Agile.md')
        [key: string]: any;
    };
}

const { node, data } = Astro.props;



// List of node types we handle with specific components
// Order matters! Container types (like blockquote) should be handled before their children (like paragraph)
const handled_types = [
    "root",
    "link",       
    "blockquote", 
    "paragraph",
    "text",
    "heading",
    "image",
    "list",
    "listItem",
    "code",
    "inlineCode",
    "table",
    "tableRow",
    "tableCell",
    "strong",
    "emphasis",
    "break",
    "html",
    "citation",
    "citations",
    "citationReference",
    "footnoteReference",
    "footnoteDefinition",    
    "tableOfContents",
    "imageGallery",
    "toolingGallery",
    "thematicBreak", 
    "leafDirective", 
    "containerDirective",
    "textDirective"
]

const other_type = !handled_types.includes(node.type)
data.dirpath = dirname(data.path)


//This logic has to be done up here because it's async work
// Only apply if it's a toolGallery code block
  const isToolingGallery = (
    node.lang === 'toolingGallery' || (node.lang === 'yaml' && node.meta?.startsWith('toolingGallery'))
  );

 

let toolGalleryTools = null;
let toolGalleryErrors: string[] = [];
let isSmallToolGallery = false


if (isToolingGallery) {  
  isSmallToolGallery = node.meta?.includes('small');

  const rawLines = node.value
    .split('\n')
    .map(line => line.trim())
    .filter(Boolean);

  const tagFilters = [];
  const rawToolIds = [];

  for (const line of rawLines) {
    const tagMatch = line.match(/^- tag:\s*(?:\[\[(.*?)\]\]|(.*))/i);
    if (tagMatch) {
      tagFilters.push((tagMatch[1] ?? tagMatch[2]).trim());
      continue;
    }

    // Otherwise treat as tool reference
    const toolMatch = line.replace(/^- /, '').trim();
    if (toolMatch) {
      rawToolIds.push(toolMatch);
    }
  }

  // Load tooling collection
  const allTools = await getCollection('tooling');
  const toolMap = new Map(allTools.map(entry => [entry.id, {
    ...entry.data,
    id: entry.id,
    filePath: entry.id,
  }]));

  const tools = [];

  // Resolve toolIds
  for (const input of rawToolIds) {
    let id = input;

    const backlinkMatch = input.match(/^\[\[(?!.*?visuals)(.*?)(?:\|.*?)?\]\]$/);
    if (backlinkMatch) {
      id = backlinkMatch[1].trim();
    }

    const resolvedId = await resolveToolId(id, allTools);
    if (resolvedId && toolMap.has(resolvedId)) {
      tools.push(toolMap.get(resolvedId));
    } else {
      toolGalleryErrors.push(input);
    }
  }

  // Add tools matching tagFilters
  const normalizeTag = tag => slugify(tag).toLowerCase();

  if (tagFilters.length > 0) {
    const tagFilteredTools = allTools
      .filter(tool => Array.isArray(tool.data.tags) && tool.data.tags.some(tag =>
        tagFilters.some(filterTag =>
          normalizeTag(filterTag) === normalizeTag(tag)
        )
      ))
      .map(entry => ({
        ...entry.data,
        id: entry.id,
        filePath: entry.id,
      }));
    
    // Add tag-matched tools if not already added
    for (const tool of tagFilteredTools) {
      if (!tools.some(t => t.id === tool.id)) {
        tools.push(tool);
      }
    }
  }

  if (toolGalleryErrors.length > 0) {
    console.warn('[toolingGallery] Missing tools for IDs:', toolGalleryErrors);
  }

  toolGalleryTools = tools;

}

// Portfolio Gallery Logic - handle async work upfront
const isPortfolioGallery = (
  node.type === "containerDirective" && 
  (node.name === 'portfolio-gallery' || node.name === 'portfolioGallery')
);

let portfolioGalleryPortfolios = null;
let portfolioGalleryErrors: string[] = [];
let portfolioGalleryConfig: Record<string, any> = {};

// Tooling Gallery Directive Logic - handle async work upfront
const isToolingGalleryDirective = (
  node.type === "containerDirective" && 
  (node.name === 'tooling-gallery' || node.name === 'toolingGallery')
);

let toolingGalleryDirectiveTools = null;
let toolingGalleryDirectiveErrors: string[] = [];
let toolingGalleryDirectiveConfig: Record<string, any> = {};

// Image Gallery Directive Logic - handle async work upfront
const isImageGalleryDirective = (
  node.type === "containerDirective" && 
  (node.name === 'image-gallery' || node.name === 'imageGallery')
);

let imageGalleryDirectiveCode = '';
let imageGalleryDirectiveConfig: Record<string, any> = {};

if (isPortfolioGallery) {
  portfolioGalleryConfig = node.attributes || {};
  const rawPortfolioIds = [];
  const tagFilters = [];
  
  if (node.children) {
    // Find list nodes in the container
    const listNodes = node.children.filter(child => child.type === 'list');
    
    for (const listNode of listNodes) {
      if (listNode.children) {
        for (const listItem of listNode.children) {
          if (listItem.type === 'listItem' && listItem.children) {
            // Look for paragraph containing text or link
            const paragraph = listItem.children.find(child => child.type === 'paragraph');
            if (paragraph && paragraph.children) {
              // Check if this is a tag filter line
              const textContent = paragraph.children
                .map(child => child.type === 'text' ? child.value : child.type === 'link' ? child.children[0]?.value || '' : '')
                .join('').trim();
              
              const tagMatch = textContent.match(/^tag:\s*(?:\[\[(.*?)\]\]|(.*))/i);
              if (tagMatch) {
                const tagName = (tagMatch[1] ?? tagMatch[2]).trim();
                if (tagName) {
                  tagFilters.push(tagName);
                  console.log('[portfolioGallery] Added tag filter:', tagName);
                }
                continue;
              }
              
              // Otherwise look for portfolio link
              const link = paragraph.children.find(child => child.type === 'link');
              if (link && link.url) {
                // Extract the portfolio path from the backlink URL
                const url = link.url;
                // Remove leading slash and .md extension if present
                const portfolioPath = url.replace(/^\//, '').replace(/\.md$/, '');
                rawPortfolioIds.push(portfolioPath);
              }
            }
          }
        }
      }
    }
  }
  
  // Load portfolio collection
  const allPortfolios = await getCollection('client-portfolios');
  const portfolioMap = new Map(allPortfolios.map(entry => [entry.id, {
    ...entry.data,
    id: entry.id,
    filePath: entry.id,
  }]));

  const portfolios = [];
  const portfolioErrors = [];

  // Resolve portfolioIds using the same pattern as toolingGallery
  for (const input of rawPortfolioIds) {
    let id = input;

    const backlinkMatch = input.match(/^\[\[(?!.*?visuals)(.*?)(?:\|.*?)?\]\]$/);
    if (backlinkMatch) {
      id = backlinkMatch[1].trim();
    }

    const resolvedId = await resolvePortfolioId(id, allPortfolios);
    if (resolvedId && portfolioMap.has(resolvedId)) {
      const portfolio = portfolioMap.get(resolvedId);
      const filename = resolvedId.split('/').pop()?.replace(/\.md$/, '') || '';
      
      portfolios.push({
        id: filename.toLowerCase().replace(/\s+/g, '-'),
        filename,
        filePath: resolvedId,
        ...portfolio,
        url: portfolio.url || '#',
        tags: portfolio.tags || [],
        portfolios: portfolio.portfolios || [],
      });
    } else {
      portfolioErrors.push(input);
    }
  }

  // Add portfolios matching tagFilters
  const normalizeTag = tag => slugify(tag).toLowerCase();

  if (tagFilters.length > 0) {
    console.log('[portfolioGallery] Searching for portfolios with tags:', tagFilters);
    
    const tagFilteredPortfolios = allPortfolios
      .filter(portfolio => portfolio.data.tags?.some(tag =>
        tagFilters.some(filterTag =>
          normalizeTag(filterTag) === normalizeTag(tag)
        )
      ))
      .map(entry => {
        const filename = entry.id.split('/').pop()?.replace(/\.md$/, '') || '';
        return {
          id: filename.toLowerCase().replace(/\s+/g, '-'),
          filename,
          filePath: entry.id,
          ...entry.data,
          url: entry.data.url || '#',
          tags: entry.data.tags || [],
          portfolios: entry.data.portfolios || [],
        };
      });
    
    console.log('[portfolioGallery] Found', tagFilteredPortfolios.length, 'portfolios matching tags');
    
    // Add tag-matched portfolios if not already added
    for (const portfolio of tagFilteredPortfolios) {
      if (!portfolios.some(p => p.filePath === portfolio.filePath)) {
        portfolios.push(portfolio);
      }
    }
  }

  if (portfolioErrors.length > 0) {
    console.warn('[portfolioGallery] Missing portfolios for IDs:', portfolioErrors);
  }

  portfolioGalleryPortfolios = portfolios;
  portfolioGalleryErrors = portfolioErrors;
}

if (isToolingGalleryDirective) {
  toolingGalleryDirectiveConfig = node.attributes || {};
  const rawToolIds = [];
  const tagFilters = [];
  
  if (node.children) {
    // Find list nodes in the container (same as portfolio gallery)
    const listNodes = node.children.filter(child => child.type === 'list');
    
    for (const listNode of listNodes) {
      if (listNode.children) {
        for (const listItem of listNode.children) {
          if (listItem.type === 'listItem' && listItem.children) {
            // Look for paragraph containing text or link
            const paragraph = listItem.children.find(child => child.type === 'paragraph');
            if (paragraph && paragraph.children) {
              // Check if this is a tag filter line
              const textContent = paragraph.children
                .map(child => child.type === 'text' ? child.value : child.type === 'link' ? child.children[0]?.value || '' : '')
                .join('').trim();
              
              const tagMatch = textContent.match(/^tag:\s*(?:\[\[(.*?)\]\]|(.*))/i);
              if (tagMatch) {
                const tagName = (tagMatch[1] ?? tagMatch[2]).trim();
                if (tagName) {
                  tagFilters.push(tagName);
                  console.log('[toolingGallery] Added tag filter:', tagName);
                }
                continue;
              }
              
              // Otherwise look for tool link
              const link = paragraph.children.find(child => child.type === 'link');
              if (link && link.url) {
                // Extract the tool path from the backlink URL
                const url = link.url;
                // Remove leading slash and .md extension if present
                const toolPath = url.replace(/^\//, '').replace(/\.md$/, '');
                rawToolIds.push(toolPath);
              }
            }
          }
        }
      }
    }
  }

  // Load tooling collection
  const allTools = await getCollection('tooling');
  const toolMap = new Map(allTools.map(entry => [entry.id, {
    ...entry.data,
    id: entry.id,
    filePath: entry.id,
  }]));

  const tools = [];
  const toolGalleryErrors = [];

  // Resolve toolIds
  for (const input of rawToolIds) {
    let id = input;

    const backlinkMatch = input.match(/^\[\[(?!.*?visuals)(.*?)(?:\|.*?)?\]\]$/);
    if (backlinkMatch) {
      id = backlinkMatch[1].trim();
    }

    const resolvedId = await resolveToolId(id, allTools);
    if (resolvedId && toolMap.has(resolvedId)) {
      tools.push(toolMap.get(resolvedId));
    } else {
      toolGalleryErrors.push(input);
    }
  }

  // Add tools matching tagFilters
  const normalizeTag = tag => slugify(tag).toLowerCase();

  if (tagFilters.length > 0) {
    console.log('[toolingGallery] Searching for tools with tags:', tagFilters);
    
    const tagFilteredTools = allTools
      .filter(tool => Array.isArray(tool.data.tags) && tool.data.tags.some(tag =>
        tagFilters.some(filterTag =>
          normalizeTag(filterTag) === normalizeTag(tag)
        )
      ))
      .map(entry => ({
        ...entry.data,
        id: entry.id,
        filePath: entry.id,
      }));
    
    console.log('[toolingGallery] Found', tagFilteredTools.length, 'tools matching tags');
    
    // Add tag-matched tools if not already added
    for (const tool of tagFilteredTools) {
      if (!tools.some(t => t.id === tool.id)) {
        tools.push(tool);
      }
    }
  }

  if (toolGalleryErrors.length > 0) {
    console.warn('[toolingGallery] Missing tools for IDs:', toolGalleryErrors);
  }

  toolingGalleryDirectiveTools = tools;
  toolingGalleryDirectiveErrors = toolGalleryErrors;
}

if (isImageGalleryDirective) {
  imageGalleryDirectiveConfig = node.attributes || {};
  
  // Extract content from directive children
  if (node.children) {
    // Find list nodes in the container
    const listNodes = node.children.filter(child => child.type === 'list');
    
    for (const listNode of listNodes) {
      if (listNode.children) {
        for (const listItem of listNode.children) {
          if (listItem.type === 'listItem' && listItem.children) {
            // Look for paragraph containing link or text
            const paragraph = listItem.children.find(child => child.type === 'paragraph');
            if (paragraph && paragraph.children) {
              // Check if there's a link node (for URLs)
              const link = paragraph.children.find(child => child.type === 'link');
              if (link && link.url) {
                // Extract URL from link node
                imageGalleryDirectiveCode += '- ' + link.url + '\n';
              } else {
                // Fallback to text content
                const textContent = paragraph.children
                  .map(child => child.type === 'text' ? child.value : '')
                  .join('').trim();
                
                if (textContent) {
                  imageGalleryDirectiveCode += '- ' + textContent + '\n';
                }
              }
            }
          }
        }
      }
    }
  }
  
  imageGalleryDirectiveCode = imageGalleryDirectiveCode.trim();
  
  console.log('[imageGallery] Extracted code:', imageGalleryDirectiveCode);
}

// Debug output to see AST structure
if (DEBUG_AST) {
  console.log(`=== AstroMarkdown Debug ===`)
  console.log(`Node type: ${node.type}`)
  console.log('Node structure:', JSON.stringify(node, null, 2))
}
---

{node.type === "root" && (() => {
  return (
    <>
      {node.children.map((child) => (
          <Astro.self node={child} data={data} />
      ))}
    </>
  );
})()}

{node.type === "heading" && (() => {
  const currentHeaderText = extractAllText(node.children).trim() || 'Untitled Section';

  const generateHeadingId = nodeForId =>
    slugify(extractAllText(nodeForId.children).trim() || 'untitled-heading');
  const id = generateHeadingId(node);

  const content = (
    <>
      <span class="heading-text">
        {node.children.map(child => (
          <Astro.self node={child} data={data} />
        ))}
      </span>
      <style>
  .heading-with-copy {
    display: flex;
    align-items: center;
    gap: 0.2rem;
    flex-wrap: nowrap;     
    max-width: 100%;
  }

  .heading-text {
    display: inline;
    line-height: inherit;
    flex-shrink: 1;
    min-width: 0;
  }
</style>

      <CopyLinkButton id={id} label={currentHeaderText} articleTitle={data.title} />
    </>
  );

  switch (node.depth) {
    case 1: return <h1 id={id} class="heading-with-copy">{content}</h1>;
    case 2: return <h2 id={id} class="heading-with-copy">{content}</h2>;
    case 3: return <h3 id={id} class="heading-with-copy">{content}</h3>;
    case 4: return <h4 id={id} class="heading-with-copy">{content}</h4>;
    case 5: return <h5 id={id} class="heading-with-copy">{content}</h5>;
    case 6: return <h6 id={id} class="heading-with-copy">{content}</h6>;
    default:
      return <div>{content}</div>;
  }
})()}


{(node.type === "strong") &&
  <strong>
    {node.children.map(child => (
      <Astro.self node={child} data={data} />
    ))}
  </strong>
}

{(node.type === "emphasis") &&
  <em>
    {node.children.map(child => (
      <Astro.self node={child} data={data} />
    ))}
  </em>
}


{(node.type === "image") &&
    <img src={node.url} />
}

{(node.type === "list") &&
  <>
    {node['ordered']
      ? <ol>
          {node.children.map((item) => (
            <Astro.self node={item} data={data} />
          ))}
        </ol>
      : <ul>
          {node.children.map((item) => (
            <Astro.self node={item} data={data} />
          ))}
        </ul>
    }
  </>
}

{(node.type === "listItem") &&
  <li class="custom-li">
    <span class="li-content">
      {node.children.map(child => (
        <Astro.self node={child} data={data} />
      ))}
    </span>
  </li>
}


{(node.type === "table") &&
  <div class="md-table-wrapper">
    <table class="md-table">
      <tbody>
        {node.children.map(row => (
          <Astro.self node={row} data={data} />
        ))}
      </tbody>
    </table>
  </div>
  <style>
     .md-table-wrapper {
        overflow-x: auto;
        margin-bottom: 1.5rem;
    }

    .md-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.95rem;
        background-color: transparent;
    }

    .md-tr:nth-child(even) {
        background-color: rgba(255, 255, 255, 0.03);
    }

    .md-td {
        border: 1px solid rgb(255, 255, 255);
        padding: 0.5rem 0.75rem;
        text-align: left;
        colrgb(255, 255, 255);
    }


  </style>
}

{(node.type === "tableRow") &&
  <tr class="md-tr">
    {node.children.map(cell => (
      <Astro.self node={cell} data={data} />
    ))}
  </tr>
}

{(node.type === "tableCell") &&
  <td class="md-td">
    {node.children.map(child => (
      <Astro.self node={child} data={data} />
    ))}
  </td>
}


{(node.type === "link") && (() => {
  // Function to extract YouTube video ID from various YouTube URL formats
  const extractYouTubeVideoId = (url) => {
    // youtu.be format
    const youtuBeMatch = url.match(/youtu\.be\/([a-zA-Z0-9_-]+)/);
    if (youtuBeMatch) return youtuBeMatch[1];
    
    // youtube.com/watch format
    const watchMatch = url.match(/youtube\.com\/watch\?.*v=([a-zA-Z0-9_-]+)/);
    if (watchMatch) return watchMatch[1];
    
    // youtube.com/embed format
    const embedMatch = url.match(/youtube\.com\/embed\/([a-zA-Z0-9_-]+)/);
    if (embedMatch) return embedMatch[1];
    
    // youtube.com/v format
    const vMatch = url.match(/youtube\.com\/v\/([a-zA-Z0-9_-]+)/);
    if (vMatch) return vMatch[1];
    
    return null;
  };

  // Function to extract text content from link children
  const extractLinkText = (children) => {
    if (!children || children.length === 0) return '';
    
    return children.map(child => {
      if (child.type === 'text') {
        return child.value || '';
      } else if (child.children) {
        return extractLinkText(child.children);
      }
      return '';
    }).join('');
  };

  // Check if this is a YouTube URL
  const videoId = extractYouTubeVideoId(node.url);
  
  if (videoId) {
    // For youtu.be URLs, preserve the si parameter if present
    let embedUrl = `https://www.youtube.com/embed/${videoId}`;
    
    // Extract si parameter from youtu.be URLs
    const siMatch = node.url.match(/[?&]si=([^&]+)/);
    if (siMatch) {
      embedUrl += `?si=${siMatch[1]}`;
    }
    
    // Extract the link text to use as caption
    const linkText = extractLinkText(node.children);
    
    return (
      <>
        <div class="youtube-embed-wrapper">
          <iframe 
            style="aspect-ratio:16/9;width:100%;height:auto" 
            src={embedUrl}
            title="YouTube video player" 
            frameborder="0" 
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" 
            referrerpolicy="strict-origin-when-cross-origin" 
            allowfullscreen
            loading="lazy"
          />
          {linkText && (
            <div class="youtube-caption">
              <div class="caption-content">
                {linkText}
              </div>
              <button 
                class="copy-url-btn" 
                onclick={`navigator.clipboard.writeText('${node.url}').then(() => {
                  const btn = event.target.closest('.copy-url-btn');
                  btn.classList.add('copied');
                  setTimeout(() => {
                    btn.classList.remove('copied');
                  }, 2000);
                }).catch(err => console.error('Failed to copy: ', err))`}
                title="Copy video URL to clipboard"
              >
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M16 3H4V16" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  <path d="M8 7H20V20H8V7Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              </button>
            </div>
          )}
        </div>
        <style>
          .youtube-embed-wrapper {
            margin: 1.5rem 0;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
          }
          
          .youtube-embed-wrapper iframe {
            display: block;
            border: none;
          }
          
          .youtube-caption {
            padding: 0.75rem 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.9rem;
            line-height: 1.4;
            color: #e2e8f0;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.75rem;
          }
          
          .caption-content {
            flex: 1;
            min-width: 0;
          }
          
          .copy-url-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 0.5rem;
            cursor: pointer;
            font-size: 0.875rem;
            color: #e2e8f0;
            transition: all 0.2s ease;
            flex-shrink: 0;
            min-width: 2.5rem;
            height: 2.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
          }
          
          .copy-url-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
          }
          
          .copy-url-btn:active {
            transform: translateY(0);
          }
          
          .copy-url-btn.copied {
            background: rgba(34, 197, 94, 0.2);
            border-color: rgba(34, 197, 94, 0.4);
            color: #4ade80;
          }
          
          .copy-url-btn svg {
            width: 16px;
            height: 16px;
            transition: all 0.2s ease;
          }
        </style>
      </>
    );
  }
  
  // Regular link handling for non-YouTube URLs
  return (
    <a href={node.url} {...(node.data?.hProperties ?? {})}>
      {node.children[0].value}
    </a>
  );
})()}

{node.type === "code" && (() => {
  const { lang, meta, value } = node;

  const isImageGallery = (
    lang === 'imageGallery' || (lang === 'yaml' && meta === 'imageGallery')
  );

  if (toolGalleryTools?.length > 0 || toolGalleryErrors.length > 0) {
      return (
        <>
          <div class="deprecation-warning">
            <div class="warning-header">
              <span class="warning-icon">⚠️</span>
              <span class="warning-title">Deprecation Warning</span>
            </div>
            <div class="warning-content">
              <p>The <code>```yaml toolingGallery</code> syntax is deprecated. Please use <code>:::tooling-gallery</code> directive syntax instead.</p>
            </div>
          </div>
          <ToolingGallery tools={toolGalleryTools || []} small={isSmallToolGallery} errors={toolGalleryErrors}/>
          <style>
            .deprecation-warning {
              margin: 1rem 0;
              padding: 1rem;
              background: linear-gradient(135deg, rgba(245, 158, 11, 0.1) 0%, rgba(245, 158, 11, 0.05) 100%);
              border: 1px solid rgba(245, 158, 11, 0.3);
              border-radius: 8px;
            }
            
            .deprecation-warning .warning-header {
              display: flex;
              align-items: center;
              gap: 0.5rem;
              margin-bottom: 0.5rem;
              font-weight: 600;
              color: #fbbf24;
            }
            
            .deprecation-warning .warning-icon {
              font-size: 1.25rem;
            }
            
            .deprecation-warning .warning-title {
              font-size: 0.9rem;
              text-transform: uppercase;
              letter-spacing: 0.05em;
            }
            
            .deprecation-warning .warning-content {
              color: #f1f5f9;
              line-height: 1.5;
              font-size: 0.9rem;
            }
            
            .deprecation-warning code {
              background: rgba(255, 255, 255, 0.1);
              padding: 0.2em 0.4em;
              border-radius: 4px;
              font-family: monospace;
            }
          </style>
        </>
      );
    }

  if (isImageGallery) {
    return (
      <>
        <div class="deprecation-warning">
          <div class="warning-header">
            <span class="warning-icon">⚠️</span>
            <span class="warning-title">Deprecation Warning</span>
          </div>
          <div class="warning-content">
            <p>The <code>```yaml imageGallery</code> syntax is deprecated. Please use <code>:::image-gallery</code> directive syntax instead.</p>
          </div>
        </div>
        <ImageGallery code={value} dirpath={data.dirpath} />
        <style>
          .deprecation-warning {
            margin: 1rem 0;
            padding: 1rem;
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.1) 0%, rgba(245, 158, 11, 0.05) 100%);
            border: 1px solid rgba(245, 158, 11, 0.3);
            border-radius: 8px;
          }
          
          .deprecation-warning .warning-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #fbbf24;
          }
          
          .deprecation-warning .warning-icon {
            font-size: 1.25rem;
          }
          
          .deprecation-warning .warning-title {
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
          }
          
          .deprecation-warning .warning-content {
            color: #f1f5f9;
            line-height: 1.5;
            font-size: 0.9rem;
          }
          
          .deprecation-warning code {
            background: rgba(255, 255, 255, 0.1);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            font-family: monospace;
          }
        </style>
      </>
    );
  }

  // Use centralized language routing strategy
  const routingStrategy = getLanguageRoutingStrategy(lang || 'text');
  
  // Handle special renderer languages
  if (routingStrategy === 'special-renderer') {
    if (lang === 'mermaid') {
      return <MermaidChart code={value} />;
    }
  }

  // Enhanced block types support using switch statement
  const blockType = lang?.toLowerCase();
  
  switch (blockType) {
    case 'slides':
      // Parse slides configuration and links
      const lines = value.trim().split('\n');
      const config = {};
      const slides = [];
      let configSection = true;
      
      for (const line of lines) {
        const trimmedLine = line.trim();
        
        // Skip empty lines
        if (!trimmedLine) continue;
        
        // Check if this is a slide link
        if (trimmedLine.startsWith('- [[')) {
          configSection = false;
          const linkMatch = trimmedLine.match(/\[\[(.*?)\|(.*?)\]\]/);
          if (linkMatch) {
            slides.push({
              path: linkMatch[1],
              title: linkMatch[2]
            });
          }
        } else if (configSection) {
          // Parse configuration options
          // Support both "key: value" and "key=value" syntax
          const colonMatch = trimmedLine.match(/^(\w+):\s*(.+)$/);
          const equalsMatch = trimmedLine.match(/^(\w+)=(.+)$/);
          
          if (colonMatch) {
            config[colonMatch[1]] = colonMatch[2].trim();
          } else if (equalsMatch) {
            config[equalsMatch[1]] = equalsMatch[2].trim();
          } else if (trimmedLine.includes('=')) {
            // Handle inline config like "theme=dark transition=slide"
            const pairs = trimmedLine.split(/\s+/);
            for (const pair of pairs) {
              const [key, value] = pair.split('=');
              if (key && value) {
                config[key] = value;
              }
            }
          }
        }
      }
      
      return (
        <SlidesEmbed slides={slides} config={config} />
      );

    default:
      // Default code block handling
      return <BaseCodeblock code={value} lang={lang ?? 'text'} />;
  }
})()}



{(node.type === "html") &&
  <div class="raw-html" set:html={node.value} />
}


{(node.type === "blockquote") &&
    <ArticleCallout node={node} />
}

{(node.type === "inlineCode") &&
  <>
    <code class="inline-code">{node.value}</code>
    <style>
      .inline-code {
        /* Typography */
        font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', 'Source Code Pro', 'Fira Code', 'Cascadia Code', 'JetBrains Mono', 'Ubuntu Mono', monospace;
        font-size: 0.875em;
        font-weight: 500;
        line-height: 1.4;
        letter-spacing: -0.01em;
        
        /* Background & Border */
        background: linear-gradient(135deg, 
          rgba(255, 255, 255, 0.08) 0%, 
          rgba(255, 255, 255, 0.04) 100%);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 6px;
        
        /* Spacing & Layout */
        padding: 0.2em 0.4em;
        margin: 0 0.1em;
        display: inline;
        
        /* Colors */
        color: #e2e8f0;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        
        /* Effects */
        box-shadow: 
          0 1px 3px rgba(0, 0, 0, 0.1),
          0 1px 2px rgba(0, 0, 0, 0.06),
          inset 0 1px 0 rgba(255, 255, 255, 0.1);
        
        /* Transitions */
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        
        /* Text wrapping - allow breaking on mobile */
        word-break: break-word;
        overflow-wrap: break-word;
        hyphens: auto;
        
        /* Ensure proper rendering */
        text-rendering: optimizeLegibility;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }
      
      /* Hover effects for interactive feel */
      .inline-code:hover {
        background: linear-gradient(135deg, 
          rgba(255, 255, 255, 0.12) 0%, 
          rgba(255, 255, 255, 0.08) 100%);
        border-color: rgba(255, 255, 255, 0.18);
        box-shadow: 
          0 2px 8px rgba(0, 0, 0, 0.15),
          0 1px 3px rgba(0, 0, 0, 0.1),
          inset 0 1px 0 rgba(255, 255, 255, 0.15);
        transform: translateY(-1px);
      }
      
      /* Focus state for accessibility */
      .inline-code:focus {
        outline: 2px solid rgba(59, 130, 246, 0.5);
        outline-offset: 2px;
      }
      
      /* Dark theme adjustments */
      @media (prefers-color-scheme: dark) {
        .inline-code {
          background: linear-gradient(135deg, 
            rgba(255, 255, 255, 0.06) 0%, 
            rgba(255, 255, 255, 0.03) 100%);
          border-color: rgba(255, 255, 255, 0.08);
          color: #f1f5f9;
        }
        
        .inline-code:hover {
          background: linear-gradient(135deg, 
            rgba(255, 255, 255, 0.1) 0%, 
            rgba(255, 255, 255, 0.06) 100%);
          border-color: rgba(255, 255, 255, 0.15);
        }
      }
      
      /* High contrast mode support */
      @media (prefers-contrast: high) {
        .inline-code {
          background: rgba(255, 255, 255, 0.15);
          border: 2px solid currentColor;
          color: inherit;
        }
      }
      
      /* Mobile responsive adjustments */
      @media (max-width: 768px) {
        .inline-code {
          font-size: 0.8em;
          padding: 0.15em 0.3em;
          word-break: break-all;
          overflow-wrap: anywhere;
        }
      }
      
      @media (max-width: 480px) {
        .inline-code {
          font-size: 0.75em;
          padding: 0.1em 0.25em;
        }
      }
      
      /* Print styles */
      @media print {
        .inline-code {
          background: transparent;
          border: 1px solid #000;
          color: #000;
          box-shadow: none;
        }
      }
    </style>
  </>
}

<!-- Anything citation-* is custom made -->
<!-- === citationReference === -->
{node.type === 'citationReference' && (
  <sup class="cite-ref">
    <a
      href={node.data?.hProperties?.href ?? ''}
      id={node.data?.hProperties?.id ?? ''}
      class="citation-link"
    >
      [{node.children?.map(child => <Astro.self node={child} data={data} />)}]
    </a>
  </sup>
)}

<!-- === single citation node === -->
{node.type === 'citation' && (
  <ArticleCitation node={node} />
)}

<!-- === citations block === -->
{node.type === 'citations' && (
  <ArticleCitationsBlock node={node} />
)}

<!-- footnoteReference and footnoteDefinition are from standard Markdown library -->
{node.type === 'footnoteReference' && (
  <sup class="footnote-ref">
    <a href={`#${node.label}`} id={`ref-${node.label}`}>
      [{node.label}]
    </a>
  </sup>
  <style>
  .footnote-ref {
    font-size: 0.6em;
    vertical-align: super;
    top: 0px;
  }

  .footnote-definition {
    font-size: 0.9em;
    margin-top: 1em;
    border-top: 1px solid #666;
    padding-top: 0.5em;
    scroll-margin-top: 10vh;
  }

</style>

)}

{node.type === 'footnoteDefinition' && (
  <div id={node.label} class="footnote-definition">
    {node.children.length === 1 && node.children[0].type === 'paragraph' ? (
      <p>
        <strong><a href={`#ref-${node.label}`}>[{node.label}]</a></strong>{' '}
        {node.children[0].children.map(child => (
          <Astro.self node={child} data={data} />
        ))}{' '}
      </p>
    ) : (
      <>
        <strong>[{node.label}]</strong>
        {node.children.map(child => (
          <Astro.self node={child} data={data} />
        ))}
      </>
    )}
  </div>
)}


{(node.type === "paragraph") &&
    <div class="paragraph">
        {node.children.map((child: any) => (
            <Astro.self node={child} data={data} />
        ))}
    </div>
}

{(node.type === "thematicBreak") && 
    <hr />
}

{(node.type === "text") && 
    <span>{node.value}</span>
}

{(node.type === "textDirective") && 
    <span class="text-directive" data-directive={node.name}>
        {node.children?.map(child => <Astro.self node={child} data={data} />) || node.value || ''}
    </span>
}

{/* Handle directive nodes from remark-directive */}
{(node.type === "leafDirective" || node.type === "containerDirective") && (() => {
  const directiveName = node.name;
  let props = node.attributes || {};
  
  // Debug: Log all directives being processed
  if (DEBUG_AST) {
    console.log(`[AstroMarkdown] Processing directive: ${directiveName}, type: ${node.type}`);
  }
  
  // For container directives, parse content as key-value pairs
  if (node.type === "containerDirective" && node.children) {
    const content = node.children
      .filter(child => child.type === 'paragraph')
      .map(child => child.children
        .filter(subchild => subchild.type === 'text')
        .map(subchild => subchild.value)
        .join(''))
      .join('\n');
    
    // Parse key="value" pairs from content
    const contentProps = {};
    const lines = content.split('\n').filter(line => line.trim());
    for (const line of lines) {
      const match = line.match(/^\s*(\S+)\s*=\s*["']([^"']*)["']\s*$/);
      if (match) {
        contentProps[match[1]] = match[2];
      }
    }
    props = { ...props, ...contentProps };
  }
  
  if (directiveName === 'figma-embed') {
    const figmaUrl = props.src || props.url || '';
    const width = props.width || '800';
    const height = props.height || '600';
    const authUser = props['auth-user'] || '';
    const embedId = `figma-embed-${Math.random().toString(36).slice(2, 10)}`;
    
    // Enhanced Figma embed URL with proper node focusing
    let embedUrl = `https://www.figma.com/embed?embed_host=lossless.group&url=${encodeURIComponent(figmaUrl)}`;
    
    // Add node-specific parameters for better focusing
    if (figmaUrl.includes('node-id=')) {
      embedUrl += '&node-id=' + (figmaUrl.match(/node-id=([^&]+)/)?.[1] || '');
    }
    
    embedUrl += '&viewer=1&scaling=min-zoom&page-id=&starting-point-node-id=';
    
    return (
      <>
        <div id={embedId} class="figma-breakout" tabindex="0">
          <div class="figma-embed-shell">
            <button
              type="button"
              class="figma-expand-btn"
              aria-label="Expand Figma design"
              aria-expanded="false"
              data-embed-id={embedId}
              data-figma-url={figmaUrl}
              data-width={width}
              data-height={height}
            >
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="m21 21-6-6m6 6v-4.8m0 4.8h-4.8"></path>
                <path d="M3 16.2V21m0 0h4.8M3 21l6-6"></path>
                <path d="M21 7.8V3m0 0h-4.8M21 3l-6 6"></path>
                <path d="M3 7.8V3m0 0h4.8M3 3l6 6"></path>
              </svg>
            </button>
            <div class="figma-embed-container" data-directive="figma-embed">
              <div class="figma-embed-wrapper">
                <iframe
                  src={embedUrl}
                  allowfullscreen
                  loading="lazy"
                  title="Figma embed"
                  style={`border: none; width: ${width}px; height: ${height}px; border-radius: 8px; max-width: 100%;`}
                ></iframe>
              </div>
              <div class="figma-embed-footer">
                <a href={figmaUrl} target="_blank" rel="noopener">Open in Figma →</a>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Fullscreen Modal -->
        <div
          id={`modal-${embedId}`}
          class="figma-modal"
          role="dialog"
          aria-modal="true"
          aria-labelledby={`modal-title-${embedId}`}
          hidden
        >
          <div class="figma-modal-content">
            <h2 id={`modal-title-${embedId}`} class="visually-hidden">Expanded Figma Design</h2>
            <button
              type="button"
              class="figma-modal-close-btn"
              aria-label="Close expanded design"
            >
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M18 6 6 18"></path>
                <path d="m6 6 12 12"></path>
              </svg>
            </button>
            <div class="figma-modal-embed-container">
              <iframe
                src={embedUrl}
                allowfullscreen
                title="Figma embed (expanded)"
                style="border: none; width: 100%; height: 100%; border-radius: 8px;"
              ></iframe>
            </div>
          </div>
        </div>
        
        <style>
          /* Breakout layout similar to Mermaid */
          .figma-breakout {
            position: relative;
            z-index: 10;
            left: 50%;
            right: 50%;
            width: 100vw;
            margin-left: -50vw;
            max-width: 100vw;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: transparent;
            box-sizing: border-box;
            margin-top: 2rem;
            margin-bottom: 2rem;
          }
          
          .figma-embed-shell {
            position: relative;
            min-width: 760px;
            width: auto;
            max-width: 1200px;
            margin: 1.25rem 0;
            overflow-x: auto;
            background: var(--bastille, #19141D);
            box-shadow: 0 4px 48px rgba(0,0,0,0.25);
            border-radius: 10px;
            border: 2px solid var(--clr-lossless-accent--brightest, #04e5e5);
            margin: 0 auto;
            display: block;
            padding: 1rem;
          }
          
          .figma-expand-btn {
            position: absolute;
            top: 0.75rem;
            right: 1.5rem;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 0.5rem;
            cursor: pointer;
            opacity: 0.8;
            transition: all 0.2s ease;
          }
          
          .figma-expand-btn:hover,
          .figma-expand-btn:focus {
            opacity: 1;
            background: rgba(0, 0, 0, 0.9);
            border-color: var(--clr-lossless-accent--brightest, #04e5e5);
            outline: none;
          }
          
          .figma-embed-container {
            border-radius: 8px;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
          }
          
          .figma-embed-wrapper {
            position: relative;
            overflow: hidden;
          }
          
          .figma-embed-wrapper iframe {
            display: block;
            border: none;
          }
          
          .figma-embed-footer {
            padding: 0.75rem 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.75rem;
            color: #9ca3af;
            text-align: right;
          }
          
          .figma-embed-footer a {
            color: var(--clr-lossless-accent--brightest, #04e5e5);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.2s ease;
          }
          
          .figma-embed-footer a:hover {
            color: var(--clr-lossless-accent--aquamarine, #6FFFD6);
          }
          
          /* Modal styles */
          .figma-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0s 0.3s linear;
            pointer-events: none;
          }
          
          .figma-modal[data-visible="true"] {
            opacity: 1;
            visibility: visible;
            transition-delay: 0s;
            pointer-events: auto;
          }
          
          .figma-modal-content {
            position: relative;
            background-color: var(--bastille, #19141D);
            padding: 4rem 2rem 2rem 2rem;
            border-radius: 8px;
            width: 95vw;
            height: 95vh;
            max-width: 1600px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            box-sizing: border-box;
            border: 2px solid var(--clr-lossless-accent--brightest, #04e5e5);
          }
          
          .figma-modal-embed-container {
            flex-grow: 1;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
          }
          
          .figma-modal-close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            cursor: pointer;
            padding: 0.75rem;
            line-height: 1;
            z-index: 10;
            border-radius: 6px;
            transition: all 0.2s ease;
          }
          
          .figma-modal-close-btn:hover {
            background: rgba(255, 0, 0, 0.7);
            border-color: #ff6b6b;
          }
          
          .visually-hidden {
            border: 0;
            clip: rect(0 0 0 0);
            height: 1px;
            margin: -1px;
            overflow: hidden;
            padding: 0;
            position: absolute;
            width: 1px;
            white-space: nowrap;
          }
          
          @media (max-width: 768px) {
            .figma-breakout {
              left: auto;
              right: auto;
              width: 100%;
              margin-left: 0;
              max-width: 100%;
              padding: 0 0.5rem;
            }
            
            .figma-embed-shell {
              min-width: auto;
              max-width: 100%;
              width: 100%;
              padding: 0.5rem;
            }
            
            .figma-embed-wrapper iframe {
              height: 400px !important;
              width: 100% !important;
            }
            
            .figma-modal-content {
              width: 95vw;
              height: 95vh;
              padding: 3rem 1rem 1rem 1rem;
            }
          }
        </style>
        
        <script is:inline define:vars={{ embedId, figmaUrl, width, height }}>
          // Modal functionality for Figma embeds
          document.addEventListener('DOMContentLoaded', () => {
            const expandBtn = document.querySelector(`[data-embed-id="${embedId}"]`);
            const modal = document.getElementById(`modal-${embedId}`);
            
            if (expandBtn && modal) {
              const closeBtn = modal.querySelector('.figma-modal-close-btn');
              let previouslyFocusedElement;
              
              const openModal = () => {
                previouslyFocusedElement = document.activeElement;
                modal.hidden = false;
                setTimeout(() => {
                  modal.setAttribute('data-visible', 'true');
                  document.body.style.overflow = 'hidden';
                  expandBtn.setAttribute('aria-expanded', 'true');
                  if (closeBtn) closeBtn.focus();
                }, 10);
              };
              
              const closeModal = () => {
                modal.setAttribute('data-visible', 'false');
                setTimeout(() => {
                  modal.hidden = true;
                }, 300);
                document.body.style.overflow = '';
                expandBtn.setAttribute('aria-expanded', 'false');
                if (previouslyFocusedElement) {
                  previouslyFocusedElement.focus();
                }
              };
              
              expandBtn.addEventListener('click', openModal);
              if (closeBtn) {
                closeBtn.addEventListener('click', closeModal);
              }
              
              // Close with Escape key
              modal.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') {
                  closeModal();
                }
              });
            }
          });
        </script>
      </>
    );
  }

  if (directiveName === 'tool-showcase') {
    // Parse the container content for markdown list items with backlinks
    let toolPaths = [];
    
    if (node.type === "containerDirective" && node.children) {
      // Find list nodes in the container
      const listNodes = node.children.filter(child => child.type === 'list');
      
      for (const listNode of listNodes) {
        if (listNode.children) {
          for (const listItem of listNode.children) {
            if (listItem.type === 'listItem' && listItem.children) {
              // Look for paragraph containing a link
              const paragraph = listItem.children.find(child => child.type === 'paragraph');
              if (paragraph && paragraph.children) {
                const link = paragraph.children.find(child => child.type === 'link');
                if (link && link.url) {
                  // Extract the tool path from the backlink URL
                  const url = link.url;
                  // Remove leading slash and .md extension if present
                  const toolPath = url.replace(/^\//, '').replace(/\.md$/, '');
                  toolPaths.push(toolPath);
                }
              }
            }
          }
        }
      }
    }
    
    if (toolPaths.length > 0) {
      return <ToolShowcaseIsland toolPaths={toolPaths} />;
    }
    
    return (
      <div class="tool-showcase-empty">
        <p>No tools found in showcase directive</p>
        <details>
          <summary>Debug Info</summary>
          <pre>{JSON.stringify({ name: directiveName, toolPaths, nodeChildren: node.children }, null, 2)}</pre>
        </details>
        <style>
          .tool-showcase-empty {
            padding: 2rem;
            text-align: center;
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid rgba(255, 0, 0, 0.3);
            border-radius: 12px;
            color: var(--clr-lossless-primary-light);
            margin: 2rem 0;
          }
        </style>
      </div>
    );
  }

  if (directiveName === 'portfolio-gallery' || directiveName === 'portfolioGallery') {
    // Use pre-computed portfolio data from top-level async logic
    if (portfolioGalleryPortfolios?.length > 0) {
      const isSmall = portfolioGalleryConfig.small === 'true' || portfolioGalleryConfig.size === 'small';
      const expanded = portfolioGalleryConfig.expanded !== 'false';
      const takeUpWholeWidth = portfolioGalleryConfig.fullWidth === 'true' || portfolioGalleryConfig.full === 'true';
      
      return (
        <>
          <PortfolioGallery 
            portfolios={portfolioGalleryPortfolios} 
            small={isSmall}
            expanded={expanded}
            takeUpWholeWidth={takeUpWholeWidth}
          />
          {portfolioGalleryErrors.length > 0 && (
            <div class="portfolio-gallery-error">
              ⚠️ Portfolio(s) not found:
              <ul>
                {portfolioGalleryErrors.map(path => <li><code>{path}</code></li>)}
              </ul>
            </div>
            <style>
              .portfolio-gallery-error {
                color: #ff6b6b;
                background-color: rgba(255, 0, 0, 0.05);
                border: 1px solid rgba(255, 0, 0, 0.2);
                padding: 0.75rem;
                margin-top: 2rem;
                border-radius: 0.5rem;
                font-size: 0.9rem;
              }
              .portfolio-gallery-error ul {
                margin: 0.5rem 0 0;
                padding-left: 1.25rem;
              }
            </style>
          )}
        </>
      );
    }
    
    return (
      <div class="portfolio-gallery-empty">
        <p>No portfolios found in portfolio-gallery directive</p>
        <details>
          <summary>Debug Info</summary>
          <pre>{JSON.stringify({ name: directiveName, config: portfolioGalleryConfig, nodeChildren: node.children }, null, 2)}</pre>
        </details>
        <style>
          .portfolio-gallery-empty {
            padding: 2rem;
            text-align: center;
            background: rgba(255, 165, 0, 0.1);
            border: 1px solid rgba(255, 165, 0, 0.3);
            border-radius: 12px;
            color: var(--clr-lossless-primary-light);
            margin: 2rem 0;
          }
        </style>
      </div>
    );
  }

  if (directiveName === 'slides' || directiveName === 'slideshow') {
    // Parse the container content for markdown list items with slide backlinks
    const slides = [];
    const config = node.attributes || {};
    
    
    if (node.type === "containerDirective" && node.children) {
      // Find list nodes in the container
      const listNodes = node.children.filter(child => child.type === 'list');
      
      for (const listNode of listNodes) {
        if (listNode.children) {
          for (const listItem of listNode.children) {
            if (listItem.type === 'listItem' && listItem.children) {
              // Look for paragraph containing a link
              const paragraph = listItem.children.find(child => child.type === 'paragraph');
              if (paragraph && paragraph.children) {
                const link = paragraph.children.find(child => child.type === 'link');
                if (link && link.url) {
                  // Extract slide path and title from backlink
                  const path = link.url.replace(/^\//, '').replace(/\.md$/, '');
                  const title = link.children?.[0]?.value || path.split('/').pop() || path;
                  
                  slides.push({ path, title });
                }
              }
            }
          }
        }
      }
    }
    
    if (slides.length > 0) {
      return <SlidesEmbed slides={slides} config={config} />;
    }
    
    return (
      <div class="slides-directive-empty">
        <p>No slides found in slides directive</p>
        <details>
          <summary>Debug Info</summary>
          <pre>{JSON.stringify({ name: directiveName, slides, config, nodeChildren: node.children }, null, 2)}</pre>
        </details>
        <style>
          .slides-directive-empty {
            padding: 2rem;
            text-align: center;
            background: rgba(255, 165, 0, 0.1);
            border: 1px solid rgba(255, 165, 0, 0.3);
            border-radius: 12px;
            color: var(--clr-lossless-primary-light);
            margin: 2rem 0;
          }
        </style>
      </div>
    );
  }





  // Handle toolingGallery directive
  if (directiveName === 'tooling-gallery' || directiveName === 'toolingGallery') {
    console.log(`[AstroMarkdown] Processing toolingGallery directive: ${directiveName}`);
    
    // Use pre-computed data from top-level async logic
    if (toolingGalleryDirectiveTools?.length > 0 || toolingGalleryDirectiveErrors.length > 0) {
      const isSmall = toolingGalleryDirectiveConfig.small === 'true' || toolingGalleryDirectiveConfig.size === 'small';
      
      return (
        <>
          <ToolingGallery tools={toolingGalleryDirectiveTools || []} small={isSmall} errors={toolingGalleryDirectiveErrors}/>
        </>
      );
    }
    
    return (
      <div class="tooling-gallery-empty">
        <p>No tools found in tooling-gallery directive</p>
        <details>
          <summary>Debug Info</summary>
          <pre>{JSON.stringify({ name: directiveName, config: toolingGalleryDirectiveConfig, nodeChildren: node.children }, null, 2)}</pre>
        </details>
        <style>
          .tooling-gallery-empty {
            padding: 2rem;
            text-align: center;
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid rgba(255, 0, 0, 0.3);
            border-radius: 12px;
            color: var(--clr-lossless-primary-light);
            margin: 2rem 0;
          }
        </style>
      </div>
    );
  }

  // Handle imageGallery directive
  if (directiveName === 'image-gallery' || directiveName === 'imageGallery') {
    console.log(`[AstroMarkdown] Processing imageGallery directive: ${directiveName}`);
    console.log(`[AstroMarkdown] imageGalleryDirectiveCode:`, imageGalleryDirectiveCode);
    
    // Use pre-computed data from top-level async logic
    if (imageGalleryDirectiveCode) {
      return (
        <>
          <ImageGallery code={imageGalleryDirectiveCode} dirpath={data.dirpath} />
        </>
      );
    }
    
    return (
      <div class="image-gallery-empty">
        <p>No content found in image-gallery directive</p>
        <details>
          <summary>Debug Info</summary>
          <pre>{JSON.stringify({ name: directiveName, config: imageGalleryDirectiveConfig, nodeChildren: node.children }, null, 2)}</pre>
        </details>
        <style>
          .image-gallery-empty {
            padding: 2rem;
            text-align: center;
            background: rgba(255, 165, 0, 0.1);
            border: 1px solid rgba(255, 165, 0, 0.3);
            border-radius: 12px;
            color: var(--clr-lossless-primary-light);
            margin: 2rem 0;
          }
        </style>
      </div>
    );
  }
  
  // Handle other directive types or show debug info
  return (
    <div class="unknown-directive" data-directive={directiveName}>
      <p>Unknown directive: <code>{directiveName}</code></p>
      <details>
        <summary>Debug Info</summary>
        <pre>{JSON.stringify({ name: directiveName, attributes: props }, null, 2)}</pre>
      </details>
    </div>
  );
})()}

{other_type && 
    <div class={`unhandled-${node.type}`}>
        {JSON.stringify(node)}
    </div>
}

<style>
  .text-directive {
    display: inline;
    color: inherit;
    font-style: inherit;
    font-weight: inherit;
  }
  
  .text-directive[data-directive] {
    /* Add subtle styling to indicate it's a directive */
    opacity: 0.9;
  }
</style>


