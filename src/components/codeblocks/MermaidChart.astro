---
import { sanitizeMermaidCode } from '../../utils/shikiHighlighter.js';
import ExpandIcon from '@assets/Icons/arrows-maximize.svg';
import CollapseIcon from '@assets/Icons/arrows-minimize.svg';

interface Props {
  code: string;
}

const { code } = Astro.props;
const sanitizedCode = sanitizeMermaidCode(code);
const chartId = `mermaid-chart-${Math.random().toString(36).slice(2, 10)}`;

---
<div id={chartId} class="mermaid-breakout" tabindex="0">
  <div class="mermaid-chart-shell">
    <button
      type="button"
      class="mermaid-expand-btn"
      aria-label="Expand chart"
      aria-expanded="false"
      data-chart-id={chartId} data-mermaid-code={sanitizedCode}>
      <ExpandIcon />
    </button>
    <div class="mermaid">{sanitizedCode}</div>
  </div>
</div>

<!-- Fullscreen Modal -->
<div
  id={`modal-${chartId}`}
  class="mermaid-modal"
  role="dialog"
  aria-modal="true"
  aria-labelledby={`modal-title-${chartId}`}
  hidden
>
  <div class="mermaid-modal-content">
    <h2 id={`modal-title-${chartId}`} class="visually-hidden">Expanded Chart</h2>
    <button
      type="button"
      class="mermaid-modal-close-btn"
      aria-label="Close expanded chart"
    >
      <CollapseIcon />
    </button>
    <div class="mermaid-modal-chart-container">
      <div class="mermaid">{sanitizedCode}</div>
    </div>
  </div>
</div>



<style>
.mermaid-breakout {
  position: relative;
  z-index: 10;
  width: 100%;
  max-width: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: transparent;
  box-sizing: border-box;
  margin: 2rem 0;
}
.mermaid-chart-shell {
  position: relative;
  min-width: 0; /* Allow shrinking to fit container */
  width: 100%;
  max-width: 85ch; /* Match article prose max-width */
  margin: 1.25rem 0;
  overflow-x: auto;
  background: var(--bastille, #19141D);
  box-shadow: 0 4px 48px rgba(0,0,0,0.25);
  border-radius: 10px;
  border: 2px solid var(--lossless-accent--brightest, #04e5e5);
  margin: 0 auto;
  display: block;
  padding: 1rem;
  min-height: 200px;
}
.mermaid {
  background: transparent !important;
  box-shadow: none !important;
  border-radius: 0 !important;
  padding: 0 !important;
  margin: 0 !important;
  display: block !important;
  width: 100% !important;
  height: auto !important;
}

.mermaid svg {
  display: block !important;
  width: 100% !important;
  height: auto !important;
  max-width: 100% !important;
}
.mermaid-expand-btn { /* Styles for the new expand button */
  position: absolute;
  top: 0.75rem;
  right: 1.5rem;
  z-index: 10;
  background: none;
  color: #fff;
  border: none;
  border-radius: 4px;
  padding: 0.25rem 0.5rem;
  cursor: pointer;
  opacity: 0.7;
  transition: opacity 0.2s;
}
.mermaid-expand-btn:hover,
.mermaid-expand-btn:focus {
  opacity: 1;
  outline: 2px solid var(--lossless-accent--brightest, #88f);
}
.mermaid-expand-btn svg {
  width: 1.25rem;
  height: 1.25rem;
  display: block; /* Helps with alignment */
}

/* Modal Styles */
.mermaid-modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.85);
  z-index: 10000;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease, visibility 0s 0.3s linear;
  pointer-events: none;
}

.mermaid-modal[data-visible="true"] {
  opacity: 1;
  visibility: visible;
  transition-delay: 0s;
  pointer-events: auto;
}

.mermaid-modal-content {
  position: relative;
  background-color: var(--bastille);
  padding: 4rem 2rem 2rem 2rem; /* extra top padding for the button */
  border-radius: 8px;
  width: 90vw;
  height: 90vh;
  max-width: 1400px;
  display: flex;
  flex-direction: column;
  box-shadow: 0 8px 32px rgba(0,0,0,0.5);
  box-sizing: border-box;
}


.mermaid-modal-chart-container {
  flex-grow: 1;
  overflow: auto;
  display: flex;
  align-items: flex-start; /* Start from top instead of center */
  justify-content: center;
  padding: 1.5rem; /* Slightly more padding for breathing room */
  padding-top: 0.5rem; /* Small top padding */
  min-height: 0; /* Allow container to shrink */
  position: relative; /* Ensure proper positioning */
}

.mermaid-modal-chart-container .mermaid {
  width: 100%;
  height: auto;
  display: flex;
  align-items: flex-start; /* Start from top */
  justify-content: center;
  min-height: 0; /* Allow container to shrink */
}

.mermaid-modal-chart-container .mermaid svg {
  max-width: 100%; /* Leave some margin on sides */
  max-height: 200vh; /* Leave some margin top/bottom */
  width: auto;
  height: auto;
  display: block;
  margin: 0 auto;
  position: relative; /* Ensure proper positioning */
}

.mermaid-modal-close-btn {
  position: absolute;
  top: 1rem;
  right: 1rem;
  background: none;
  border: none;
  color: #fff;
  cursor: pointer;
  padding: 0.5rem;
  line-height: 1;
  z-index: 10;
}
.mermaid-modal-close-btn svg {
  width: 1.5rem;
  height: 1.5rem;
  display: block; /* Helps with alignment */
}

/* Visually hidden class for accessibility */
.visually-hidden {
  border: 0;
  clip: rect(0 0 0 0);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  width: 1px;
  white-space: nowrap;
}

@media (max-width: 768px) {
  .mermaid-breakout {
    left: auto;
    right: auto;
    width: 100%;
    margin-left: 0;
    max-width: 100%;
    padding: 0 0.5rem;
  }

  .mermaid-chart-shell {
    min-width: 0;
    max-width: 100%;
    width: 100%;
    padding: 0.5rem;
  }

  .mermaid {
    width: 100% !important;
    overflow-x: auto;
  }

  .mermaid-modal-content {
    width: 95vw;
    height: 95vh;
    padding: 3rem 1rem 1rem 1rem;
  }

  .mermaid-modal-chart-container {
    padding: 1rem;
    padding-top: 0.25rem; /* Small top padding on mobile */
  }
}

/* Ensure charts don't get too wide on large screens */
@media (min-width: 1200px) {
  .mermaid-chart-shell {
    max-width: 85ch; /* Keep consistent with article prose width */
  }
}

</style>



<script is:inline>
  // Mermaid rendering logic (custom base theme, transparent background)
  // Dynamically resolve CSS variable for primary text color at runtime
  function getCssVar(name, fallback) {
    return getComputedStyle(document.documentElement).getPropertyValue(name).trim() || fallback;
  }

  const bodyColor = getCssVar('--clr-body', '#e0e0e0');
  const primaryNodeBg = getCssVar('--clr-primary-bg', '#181818');
  const secondaryNodeBg = getCssVar('#64F4a4');
  const edgeLabelBg = getCssVar('--clr-aquamarine', '#64d4a4');
  const hippieBlue = getCssVar('--clr-hippie-blue', '#50a3b3');
  const secondaryTextClr = getCssVar('--clr-hippie-blue', '#50a3b3');
  const clusterBkg = getCssVar('--clr-gunmetal', '#283139');
  const lineClr = getCssVar('--clr-aqua-brightest', '#69e2e3');
  const fontFmly = 'Open Sans, sans-serif';

  const mermaidConfig = {
    startOnLoad: false,
    theme: 'base', // Use base for full customizability
    themeVariables: {
      darkMode: true,
      background: 'transparent', // No background for SVG/chart
      primaryColor: primaryNodeBg,
      primaryBorderColor: '#6fffd6',
      primaryTextColor: bodyColor,
      secondaryColor: '#BF23F7',
      secondaryTextColor: secondaryTextClr,
      clusterBkg: clusterBkg,
      lineColor: lineClr,
      fontFamily: fontFmly,
      // Custom class colors that match our theme
      decisionBkgColor: '#BF23F7', // Purple for decision nodes
      decisionBorderColor: '#6fffd6',
      processBkgColor: primaryNodeBg, // Dark background for process nodes
      processBorderColor: '#6fffd6',
      roleBkgColor: getCssVar('--clr-aquamarine', '#64d4a4'), // Aquamarine for role nodes
      roleBorderColor: '#6fffd6',
      // Add more custom variables here as needed
    }
  };

  console.log('[MermaidChart] Initializing Mermaid chart');

  if (!window.__MERMAID_LOADED__) {
    console.log('[MermaidChart] Loading Mermaid library...');
    import('https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs')
      .then((mermaid) => {
        console.log('[MermaidChart] Mermaid library loaded successfully');
        mermaid.default.initialize(mermaidConfig);
        console.log('[MermaidChart] Mermaid initialized with config:', mermaidConfig);
        
        // Run mermaid on all charts including this one
        mermaid.default.run();
        console.log('[MermaidChart] Mermaid.run() completed');
        
        window.mermaid = mermaid.default;
        window.__MERMAID_LOADED__ = true;
      })
      .catch((error) => {
        console.error('[MermaidChart] Failed to load Mermaid library:', error);
      });
  } else {
    console.log('[MermaidChart] Mermaid library already loaded, re-initializing...');
    window.mermaid?.initialize(mermaidConfig);
    window.mermaid?.run();
    console.log('[MermaidChart] Mermaid re-initialization completed');
  }

  // Function to re-render mermaid charts (for dynamically injected content)
  window.renderMermaidCharts = function() {
    console.log('[MermaidChart] renderMermaidCharts called');
    if (window.mermaid) {
      console.log('[MermaidChart] Re-rendering all mermaid charts...');
      window.mermaid.run();
      console.log('[MermaidChart] Re-render completed');
    } else {
      console.warn('[MermaidChart] Mermaid library not available for re-render');
    }
  };

  // Function to center SVG in modal
  function centerModalSvg(modal) {
    const svg = modal.querySelector('.mermaid svg');
    if (svg) {
      svg.style.maxWidth = '100%'; // Leave some margin on sides
      svg.style.maxHeight = '200vh'; // Leave some margin top/bottom
      svg.style.width = 'auto';
      svg.style.height = 'auto';
      svg.style.display = 'block';
      svg.style.margin = '0 auto';
      svg.style.position = 'relative';
    }
  }

  // Handle window resize for modal centering
  window.addEventListener('resize', () => {
    const visibleModal = document.querySelector('.mermaid-modal[data-visible="true"]');
    if (visibleModal) {
      centerModalSvg(visibleModal);
    }
  });

  // Initialize renderMermaidCharts function immediately
  if (!window.renderMermaidCharts) {
    window.renderMermaidCharts = function() {
      console.log('[MermaidChart] renderMermaidCharts called (fallback)');
      if (window.mermaid) {
        console.log('[MermaidChart] Re-rendering all mermaid charts...');
        window.mermaid.run();
        console.log('[MermaidChart] Re-render completed');
      } else {
        console.warn('[MermaidChart] Mermaid library not available for re-render');
      }
    };
  }


  // Modal Toggle Logic for all Mermaid Charts
  document.addEventListener('DOMContentLoaded', () => {
    const expandButtons = document.querySelectorAll('.mermaid-expand-btn');

    expandButtons.forEach(expandBtn => {
      const chartId = expandBtn.getAttribute('data-chart-id');
      const modal = document.getElementById(`modal-${chartId}`);

      if (modal) {
        const closeBtn = modal.querySelector('.mermaid-modal-close-btn');
        let previouslyFocusedElement;

        const openModal = () => {
          previouslyFocusedElement = document.activeElement;
          const rawMermaidCode = expandBtn.getAttribute('data-mermaid-code');
          const modalMermaidDiv = modal.querySelector('.mermaid');

          if (modalMermaidDiv && rawMermaidCode && window.mermaid) {
            // Restore raw code and prepare for re-render
            modalMermaidDiv.innerHTML = ''; // Clear current content (likely error SVG)
            modalMermaidDiv.removeAttribute('data-processed'); // Allow mermaid to reprocess
            modalMermaidDiv.textContent = rawMermaidCode; // Set the raw mermaid code

            // Ensure modal is visible BEFORE rendering, so dimensions are correct
            modal.hidden = false;
            // Use a minimal timeout to ensure DOM updates for visibility are processed
            // and CSS transitions can start before mermaid tries to calculate layout.
            setTimeout(() => {
              modal.setAttribute('data-visible', 'true');

              // Now that modal is visible and raw code is in place, render the chart
              try {
                window.mermaid.run({ nodes: [modalMermaidDiv] });
                
                // Ensure proper centering after rendering
                setTimeout(() => {
                  centerModalSvg(modal);
                  
                  // Scroll chart container to top to ensure chart is visible
                  const chartContainer = modal.querySelector('.mermaid-modal-chart-container');
                  if (chartContainer) {
                    chartContainer.scrollTop = 0;
                    // Force scroll to top after a brief delay to ensure content is rendered
                    setTimeout(() => {
                      chartContainer.scrollTop = 0;
                    }, 100);
                  }
                  
                  // Set up resize observer to keep chart centered
                  const resizeObserver = new ResizeObserver(() => {
                    centerModalSvg(modal);
                  });
                  resizeObserver.observe(modal);
                  
                  // Store observer for cleanup
                  modal._resizeObserver = resizeObserver;
                }, 50); // Small delay to ensure rendering is complete
              } catch (e) {
                console.error('Error rendering Mermaid chart in modal:', e);
                // Optionally, display a user-friendly error in modalMermaidDiv
                modalMermaidDiv.textContent = 'Error rendering chart.';
              }

              document.body.style.overflow = 'hidden'; // Prevent background scroll
              expandBtn.setAttribute('aria-expanded', 'true');
              if (closeBtn) closeBtn.focus(); else modal.focus(); // Focus management
            }, 10); // Small delay for visibility and DOM readiness
          } else {
            // Fallback or error if essential elements/data are missing
            console.error('Cannot open modal: mermaid instance, modal div, or raw code missing.');
            // Still show the modal structure if it exists, but chart won't render.
            if (modal) {
                modal.hidden = false;
                setTimeout(() => {
                    modal.setAttribute('data-visible', 'true');
                    document.body.style.overflow = 'hidden';
                    expandBtn.setAttribute('aria-expanded', 'true');
                    if (closeBtn) closeBtn.focus(); else modal.focus();
                }, 10);
            }
          }
        };

        const closeModal = () => {
          modal.setAttribute('data-visible', 'false');
          setTimeout(() => {
            modal.hidden = true;
          }, 300); // Match CSS transition duration
          
          // Clean up resize observer
          if (modal._resizeObserver) {
            modal._resizeObserver.disconnect();
            modal._resizeObserver = null;
          }
          
          document.body.style.overflow = ''; // Restore background scroll
          expandBtn.setAttribute('aria-expanded', 'false');
          if (previouslyFocusedElement) {
            previouslyFocusedElement.focus(); // Restore focus
          }
        };

        expandBtn.addEventListener('click', openModal);
        if (closeBtn) {
          closeBtn.addEventListener('click', closeModal);
        }

        // Close modal with Escape key
        modal.addEventListener('keydown', (event) => {
          if (event.key === 'Escape') {
            closeModal();
          }
        });
        
        // Basic focus trapping within the modal
        const focusableElementsString = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, [tabindex="0"], [contenteditable]';
        modal.addEventListener('keydown', (event) => {
          if (event.key === 'Tab') {
            const focusableElements = Array.from(modal.querySelectorAll(focusableElementsString));
            if (focusableElements.length === 0) return;
            const firstElement = focusableElements[0];
            const lastElement = focusableElements[focusableElements.length - 1];

            if (event.shiftKey) { // Shift + Tab
              if (document.activeElement === firstElement) {
                lastElement.focus();
                event.preventDefault();
              }
            } else { // Tab
              if (document.activeElement === lastElement) {
                firstElement.focus();
                event.preventDefault();
              }
            }
          }
        });
      }
    });
  });
</script>
