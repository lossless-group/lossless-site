---
// Core imports
import { getCollection } from "astro:content";
import path from 'node:path';
import fs from 'node:fs/promises';
import { toProperCase } from '@utils/slugify';
import type { ReferenceItem } from '../../types/client-data.d';
import ReferenceGrid from '@components/reference/ReferenceGrid.astro';
import "../../styles/global.css";

interface Props {
  client: string;
  contentBasePath: string;
}

const { client, contentBasePath } = Astro.props;

// Load reference-terms.json
let referenceTerms = { vocabulary: [], concepts: [] };

// Import contentBasePath from envUtils which handles the correct path based on DEPLOY_ENV
import { resolvedContentPath } from '@utils/envUtils';

// Debug: Log the contentBasePath and current working directory
console.log('contentBasePath from envUtils:', resolvedContentPath);
console.log('process.cwd():', process.cwd());
console.log('client:', client);

// First try with the exact client name, then with proper case
try {
  // Try exact client name - use contentBasePath from envUtils
  const exactPath = path.join(resolvedContentPath, 'client-content', client, 'reference-terms.json');
  console.log('Trying to load reference terms from:', exactPath);
  
  try {
    // Check if file exists first
    await fs.access(exactPath, fs.constants.F_OK);
    console.log('File exists, attempting to read...');
    
    const raw = await fs.readFile(exactPath, 'utf-8');
    referenceTerms = JSON.parse(raw);
    console.log('Successfully loaded reference terms from exact path');
  } catch (fileErr) {
    console.error('Error reading exact path:', fileErr);
    throw fileErr; // Re-throw to trigger the outer catch
  }
} catch (firstErr) {
  console.log('First attempt failed, trying with proper case...');
  try {
    // If that fails, try with proper case
    const properClient = toProperCase(client);
    const properCasePath = path.join(contentBasePath, 'client-content', properClient, 'reference-terms.json');
    console.log('Trying to load reference terms from:', properCasePath);
    
    try {
      // Check if file exists first
      await fs.access(properCasePath, fs.constants.F_OK);
      console.log('File exists, attempting to read...');
      
      const raw = await fs.readFile(properCasePath, 'utf-8');
      referenceTerms = JSON.parse(raw);
      console.log('Successfully loaded reference terms from proper case path');
    } catch (fileErr) {
      console.error('Error reading proper case path:', fileErr);
      throw fileErr; // Re-throw to trigger the outer catch
    }
  } catch (secondErr) {
    console.warn(`No reference terms found for client: ${client} (tried both exact and proper case)`);
    console.warn('Error details:', secondErr);
  }
}

// Helper functions
function normalizeTerm(term: string): string {
  return term.toLowerCase().replace(/-/g, '');
}

function toReferenceItems(entries: any[], collection: 'vocabulary' | 'concepts'): ReferenceItem[] {
  if (!Array.isArray(entries)) {
    console.warn('Expected entries to be an array, got:', entries);
    return [];
  }

  return entries
    .map(entry => {
      if (!entry) {
        console.warn('Encountered undefined entry in entries array');
        return null;
      }

      const slug = String(entry.slug || entry.id || '').trim();
      const title = entry.data?.title || 
                   (slug ? toProperCase(slug.replace(/[-_]/g, ' ')) : 'Untitled');

      return {
        id: entry.id || slug || `missing-id-${Math.random().toString(36).substr(2, 9)}`,
        slug,
        collection,
        data: {
          title,
          aliases: Array.isArray(entry.data?.aliases) ? entry.data.aliases : [],
          description: entry.data?.lede || entry.data?.description || '',
          tags: Array.isArray(entry.data?.tags) ? entry.data.tags : []
        },
        originalFilename: entry.id || slug || ''
      };
    })
    .filter((item): item is ReferenceItem => item !== null);
}

function createLookupMap(items: ReferenceItem[]): Map<string, ReferenceItem> {
  const map = new Map<string, ReferenceItem>();
  for (const item of items) {
    map.set(normalizeTerm(item.data.title), item);
  }
  return map;
}

// Get and process collections
const vocabEntries = await getCollection('vocabulary');
const conceptEntries = await getCollection('concepts');

const allVocabItems = toReferenceItems(vocabEntries, 'vocabulary');
const allConceptItems = toReferenceItems(conceptEntries, 'concepts');

const vocabMap = createLookupMap(allVocabItems);
const conceptMap = createLookupMap(allConceptItems);

function findMatchingItems(titles: string[], map: Map<string, ReferenceItem>): ReferenceItem[] {
  return titles
    .map(title => map.get(normalizeTerm(title)))
    .filter((item): item is ReferenceItem => item !== undefined);
}

const clientVocab = findMatchingItems(referenceTerms.vocabulary, vocabMap);
const clientConcepts = findMatchingItems(referenceTerms.concepts, conceptMap);
---

<!-- Reference Section HTML -->
<section class="reference-section">
  <!-- Vocabulary Section -->
  {clientVocab.length > 0 && (
    <div class="reference-category">
      <h2>Vocabulary</h2>
      <ReferenceGrid items={clientVocab} />
    </div>
  )}

  <!-- Concepts Section -->
  {clientConcepts.length > 0 && (
    <div class="reference-category">
      <h2>Concepts</h2>
      <ReferenceGrid items={clientConcepts} />
    </div>
  )}
</section>

<style>
  .reference-section {
    padding: 2rem 0;
    opacity: 1;
    transform: none;
  }

  .reference-category {
    margin-bottom: 3.5rem;
  }

  .reference-category h2 {
    font-family: var(--ff-base);
    font-weight: var(--fw-bold);
    font-size: 1.75rem;
    line-height: 1.2;
    margin-bottom: 1.5rem;
    color: var(--clr-heading--secondary); /* --hippie-blue from theme */
    position: relative;
    padding-bottom: 0.75rem;
  }

  .reference-category h2::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    width: 3rem;
    height: 3px;
    background: linear-gradient(90deg, var(--clr-lossless-primary-light), var(--clr-lossless-accent--brightest));
    border-radius: 3px;
  }

  @keyframes fadeInSlideUp {
    from {
      opacity: 0;
      transform: translateY(30px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @media (max-width: 768px) {
    .reference-section {
      padding: 1.5rem 0;
    }
    
    .reference-category h2 {
      font-size: 1.5rem;
      margin-bottom: 1.25rem;
    }
  }
</style>