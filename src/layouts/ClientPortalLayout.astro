---
import Layout from '@layouts/Layout.astro';
import CollectionReaderLayout from '@layouts/CollectionReaderLayout.astro';
import ReferenceGrid from '@components/reference/ReferenceGrid.astro';
import ThinGradientBleedSeparator from '@components/basics/separators/ThinGradientBleedSeparator.astro';
import { contentBasePath } from '@utils/envUtils';
import { getCollection } from "astro:content";
import type { CollectionEntry } from 'astro:content';
import { toProperCase, slugify } from '@utils/slugify';
import path from 'node:path'
import { resolveToolId } from '@utils/toolUtils';
import ToolingGallery from '@components/markdown/ToolingGallery.astro';


interface Props {
  client: string;
  currentEssay: CollectionEntry<'client-content'>;
  essays: CollectionEntry<'client-content'>[];
  clientVocab: CollectionEntry<'vocabulary'>[];
  clientConcepts: CollectionEntry<'concepts'>[];
  slug?: string;
}

const { client, slug } = Astro.props;

import { processEntries } from '@utils/slugify';
import { transformContentPathToRoute } from '@utils/routing/routeManager';

const allClientEssays = await getCollection('client-content');
const allVocabulary = processEntries(await getCollection('vocabulary'));
const allConcepts = processEntries(await getCollection('concepts'));

// Load reference-terms.json
// IMPORTANT: Clients must have proper cased names (Laerdal). "laerdal" will fail
const referenceTermsPath = path.resolve(contentBasePath, `client-content/${toProperCase(client)}/reference-terms.json`);
let referenceTerms = { vocabulary: [], concepts: [] };

try {
  const raw = await fs.readFile(referenceTermsPath, 'utf-8');
  referenceTerms = JSON.parse(raw);
} catch (err) {
  console.warn(`No reference terms found for client: ${client}`);
}

// Slugify helper
function normalizeSlugFromPath(term: string): string {
  const transformed = transformContentPathToRoute(term); // → "/more-about/explainers-for-ai/ai-avatars"
  return transformed.split('/').slice(2).join('/');       // → "explainers-for-ai/ai-avatars"
}

// Extract data for client
const rawEssays = allClientEssays.filter(e => e.id.startsWith(`${client.toLowerCase()}/essays/`));
const essays = processEntries(rawEssays);

let currentEssay = essays[0];
if (slug) {
  currentEssay = essays.find(e => {
    const parts = e.slug.split('/');
    const lastPart = parts[parts.length - 1];
    return lastPart === slug;
  });
}

const vocabPaths = referenceTerms.vocabulary.map(normalizeSlugFromPath);
const conceptPaths = referenceTerms.concepts.map(normalizeSlugFromPath);

const clientVocab = allVocabulary.filter(e => vocabPaths.includes(e.slug));
const clientConcepts = allConcepts.filter(e => conceptPaths.includes(e.slug));

// For the Tooling section
import yaml from 'js-yaml';
import fs from 'node:fs/promises';

let toolGalleryTools = [];

try {
  // IMPORTANT: Clients must have proper cased names (Laerdal). "laerdal" will fail
  const yamlPath = path.resolve(contentBasePath, `client-content/${toProperCase(client)}/tool-gallery.yaml`);
  const rawYaml = await fs.readFile(yamlPath, 'utf-8');
  const config = yaml.load(rawYaml);

  const tagFilters = [];
  const rawToolIds = [];

  for (const item of config) {
      if (item.tag) {
        const raw = String(item.tag).trim();
        const match = raw.match(/^\[\[(.*?)\]\]$/);
        const tag = match ? match[1].trim() : raw;
        tagFilters.push(tag);
      } else if (typeof item === 'string') {
        const raw = item.trim();
        const match = raw.match(/^\[\[(.*?)\]\]$/);
        const toolId = match ? match[1].trim() : raw;
        rawToolIds.push(toolId);
      }
  }


  const allTools = await getCollection('tooling');
  const toolMap = new Map(allTools.map(entry => [entry.id, {
    ...entry.data,
    id: entry.id,
    filePath: entry.id,
  }]));

  const tools = [];
  const normalizeTag = tag => slugify(tag).toLowerCase();

  for (const input of rawToolIds) {
    let id = input;
    const match = input.match(/^\[\[(?!.*?visuals)(.*?)(?:\|.*?)?\]\]$/);
    if (match) id = match[1].trim();

    const resolvedId = await resolveToolId(id, allTools);
    if (resolvedId && toolMap.has(resolvedId)) tools.push(toolMap.get(resolvedId));
  }

  if (tagFilters.length > 0) {
    const tagFiltered = allTools
      .filter(tool => tool.data.tags?.some(tag =>
        tagFilters.some(filter => normalizeTag(filter) === normalizeTag(tag))
      ))
      .map(entry => ({
        ...entry.data,
        id: entry.id,
        filePath: entry.id,
      }));

    for (const tool of tagFiltered) {
      if (!tools.some(t => t.id === tool.id)) tools.push(tool);
    }
  }

  toolGalleryTools = tools;
} catch (err) {
  console.warn(`No tool-gallery.yaml for ${client}`);
}

---

<Layout title={`Client Portal: ${toProperCase(client)}`}>
  <div class="client-reader-wrapper">
    <h1 class="text-3xl font-bold mb-6">Client Portal: {toProperCase(client)}</h1>

    <button id="toggle-reader" class="toggle-button">Hide Reader</button>

    <div id="reader-section" class="collapsible-section expanded">
      {currentEssay ? (
        <CollectionReaderLayout 
          collection={`client-content/${client}`} 
          entry={currentEssay} 
          essays={essays} 
          mode="client"
          client={client}
        />
      ) : (
        <p>No published essays for this client.</p>
      )}
    </div>

  <button id="toggle-references" class="toggle-button">Hide References</button>

  <div id="reference-section" class="collapsible-section expanded">
    {(clientVocab.length > 0 || clientConcepts.length > 0) && (
      <div class="mt-12">
        {clientVocab.length > 0 && (
          <section class="mb-12">
            <h2 class="text-2xl font-bold mb-4">Vocabulary</h2>
            <ReferenceGrid items={clientVocab} />
          </section>
        )}

        {clientConcepts.length > 0 && (
          <>
            <ThinGradientBleedSeparator height="2px" marginTop="2rem" marginBottom="2rem" />
            <section>
              <h2 class="text-2xl font-bold mb-4">Concepts</h2>
              <ReferenceGrid items={clientConcepts} />
            </section>
          </>
        )}
      </div>
    )}
  </div>

    {toolGalleryTools.length > 0 && (
    <>
      <ThinGradientBleedSeparator height="2px" marginTop="2rem" marginBottom="2rem" />
      <section class="mb-12">
        <h2 class="text-2xl font-bold mb-4">Related Tools</h2>
        <ToolingGallery tools={toolGalleryTools} />
      </section>
    </>
  )}

  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const button = document.getElementById('toggle-reader');
      const section = document.getElementById('reader-section');

      button.addEventListener('click', () => {
        const isCollapsed = section.classList.toggle('collapsed');
        section.classList.toggle('expanded', !isCollapsed);
        button.textContent = isCollapsed ? 'Show Reader' : 'Hide Reader';
      });
    });

    const refButton = document.getElementById('toggle-references');
    const refSection = document.getElementById('reference-section');

    refButton.addEventListener('click', () => {
      const isCollapsed = refSection.classList.toggle('collapsed');
      refSection.classList.toggle('expanded', !isCollapsed);
      refButton.textContent = isCollapsed ? 'Show References' : 'Hide References';
    });

  </script>
</Layout>

<style>
.client-reader-wrapper {
  padding: 2rem 1.5rem;
}

@media (min-width: 640px) {
  .client-reader-wrapper {
    padding: 3rem 2rem;
  }
}

@media (min-width: 1024px) {
  .client-reader-wrapper {
    padding: 4rem 3rem;
  }
}

.toggle-button {
  background: var(--clr-lossless-primary, #333);
  color: white;
  padding: 0.5rem 1rem;
  border-radius: 8px;
  font-weight: 600;
  margin-top: 2rem;
  margin-bottom: 1rem;
  border: none;
  cursor: pointer;
}

.collapsible-section {
  transition: max-height 0.4s ease, opacity 0.3s ease;
  overflow: hidden;
  max-height: 5000px;
  opacity: 1;
}

.collapsible-section.collapsed {
  max-height: 0;
  opacity: 0;
  pointer-events: none;
}
</style>
