---
/**
 * OneArticle.astro
 * Layout for displaying a single article in a centered, readable format
 * Handles markdown processing with remark plugins
 */

import { unified } from 'unified';
import remarkParse from 'remark-parse';
import remarkGfm from 'remark-gfm';
import remarkBacklinks from '@utils/markdown/remark-backlinks';
import remarkImages from '@utils/markdown/remark-images';
import remarkCallouts from '@utils/markdown/remark-callout-handler';
import remarkCitations from '@utils/markdown/remarkCitations';
import DebugMarkdown from '@components/markdown/DebugMarkdown.astro';
import { markdownDebugger } from '@utils/markdown/markdownDebugger';
import remarkRehype from 'remark-rehype';
import rehypeMermaid from 'rehype-mermaid';
import rehypeStringify from 'rehype-stringify';

interface Props {
  Component: any;
  data: Record<string, any>;
  content: string;
  markdownFile?: string;
}

const { Component, data, content, markdownFile } = Astro.props;

// === BEGIN: Mermaid Variable Interpolation ===
// Helper function: interpolate variables in mermaid code blocks in Markdown
function interpolateMermaidVariables(markdown, variables = {}) {
  // Defensive: always coerce markdown to string
  const safeMarkdown = typeof markdown === 'string' ? markdown : '';
  // Replace variables in all mermaid code blocks
  return safeMarkdown.replace(/```mermaid([\s\S]*?)```/g, (_unused, code) => {
    // Defensive: ensure code is always a string fallback
    let interpolated = typeof code === 'string' ? code : '';
    // Replace ${variable} and [...variable] patterns
    interpolated = interpolated
      // Replace ${variable} patterns
      .replace(/\$\{([a-zA-Z0-9_\-\.]+)\}/g, (_m, varName) => {
        return Object.prototype.hasOwnProperty.call(variables, varName) ? String(variables[varName]) : '';
      })
      // Replace [...variable] patterns
      .replace(/\[\.\.\.([a-zA-Z0-9_\-\.]+)\]/g, (_m, varName) => {
        return Object.prototype.hasOwnProperty.call(variables, varName) ? String(variables[varName]) : '';
      });
    // Remove [variable] and [...variable] only when inside a path or label (i.e., after / or .)
    interpolated = interpolated.replace(/([/.])\[(?:\.\.\.)?[a-zA-Z0-9_\-\.]+\]/g, '$1');
    // Normalize all non-breaking and exotic spaces to standard space (U+0020)
    interpolated = interpolated.replace(/[\u00A0\u202F]/g, ' ');
    return `\`\`\`mermaid${interpolated}\`\`\``;
  });
}
// === END: Mermaid Variable Interpolation ===

// Get variables from data or context (expand as needed)
const variables = { tag: data?.tag || '', collection: data?.collection || '' };
const preprocessedContent = interpolateMermaidVariables(content, variables);

// Process with our custom remark plugins to get MDAST
const processor = unified()
  .use(remarkParse)           // 1. Parse markdown to MDAST
  .use(remarkGfm)
  .use(remarkImages)         
  .use(remarkBacklinks)       
  .use(remarkCitations)       
  .use(remarkCallouts)       


// First parse to MDAST
const mdast = processor.parse(preprocessedContent || '');
// console.log("=== Raw MDAST ===", JSON.stringify(mdast, null, 2));

const transformedMdast = await processor.run(mdast);

// Generate HTML with only rehype and rehype-mermaid (no remark plugins)
const astroCompiledHTML = await unified()
  .use(remarkParse) // Add parser for Markdown
  .use(remarkRehype) 
  .use(rehypeMermaid, {
    mermaidConfig: {
      theme: 'dark',
      themeVariables: {
        fontFamily: 'var(--ff-body, Arial, sans-serif)',
        background: 'transparent',
      }
    }
  })
  .use(rehypeStringify) 
  .process(preprocessedContent || '');

// Debug output to see AST structure
markdownDebugger.log('OneArticle.astro Debug');
markdownDebugger.writeDebugFile('transformed-mdast', transformedMdast);
markdownDebugger.verbose('MDAST structure:', transformedMdast);

const html = astroCompiledHTML.toString();

// DEBUG: Output the compiled HTML to the server-side console for immediate inspection
console.log('Compiled HTML:', html);

// Update: Extract SVG blocks generated by rehypeMermaid
const mermaidBlocks = [];
const mermaidSvgRegex = /<svg[^>]*>[\s\S]*?<\/svg>/g;
let svgMatch;
while ((svgMatch = mermaidSvgRegex.exec(html)) !== null) {
  mermaidBlocks.push(svgMatch[0]); // full <svg>...</svg>
}

// DEBUG: Output the extracted mermaid SVG blocks
console.log('Extracted mermaid SVG blocks:', mermaidBlocks);

markdownDebugger.verbose('Compiled HTML:', html);

---

<head>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mermaid@10.9.0/dist/mermaid.min.css">
</head>

<div class="one-article">
  {markdownFile && <DebugMarkdown content={content} markdownFile={markdownFile} />}
  {/* Render only the extracted mermaid blocks here */}
  <section class="mermaid-blocks">
    {mermaidBlocks.length === 0 && <p>No mermaid blocks found</p>}
    {mermaidBlocks.length > 0 && (
      mermaidBlocks.map(block => (
        // Render each extracted Mermaid block using Astro's set:html directive
        <div class="mermaid-block" set:html={block} />
      ))
    )}
  </section>
  <Component 
    content={transformedMdast}
    compiledContent={astroCompiledHTML.toString()}
    data={data}
  >
    <slot />
  </Component>
</div>

<style>
  .one-article {
    width: 100%;
    max-width: var(--content-width, 1200px);
    margin: 0 auto;
    padding: 2rem 1rem;
  }

  @media (min-width: 768px) {
    .one-article {
      padding: 4rem 2rem;
    }
  }
</style>